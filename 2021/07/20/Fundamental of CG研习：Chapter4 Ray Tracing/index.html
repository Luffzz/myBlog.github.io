

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/myBlog.github.io/img/favicon.png">
  <link rel="icon" href="/myBlog.github.io/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>Fundamental of CG研习：Chapter4 Ray Tracing - DaojiChezhi&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/myBlog.github.io/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/myBlog.github.io/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"luffzz.github.io","root":"/myBlog.github.io/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/myBlog.github.io/js/utils.js" ></script>
  <script  src="/myBlog.github.io/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/myBlog.github.io/">&nbsp;<strong>DaojiChezhi's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/myBlog.github.io/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/myBlog.github.io/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/myBlog.github.io/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/myBlog.github.io/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/myBlog.github.io/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/myBlog.github.io/img/stay_with_me.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Fundamental of CG研习：Chapter4 Ray Tracing">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-07-20 15:37" pubdate>
        2021年7月20日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      45
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Fundamental of CG研习：Chapter4 Ray Tracing</h1>
            
            <div class="markdown-body">
              <h1 id="4-Ray-Tracing"><a href="#4-Ray-Tracing" class="headerlink" title="4 Ray Tracing"></a>4 Ray Tracing</h1><p>本章讨论光线追踪技术. </p>
<p>基本上, 渲染是一个将一系列物体, 场景的布置作为输入, 并输出相应的像素阵列的过程.而渲染亦可分为两类: object-order rendering与image-order rendering. </p>
<ul>
<li>object-order rendering按顺序考虑要渲染的每个物体, 每当考虑一个物体时, 更新与这一物体有关联的所有像素点.</li>
<li>image-order rendering则按顺序考虑每个像素点并计算这一像素的最终值, 因此在计算时, 需要考虑所有可能影响这一像素值的物体.</li>
</ul>
<p>宽泛地讲, image-order rendering的工作原理会更简单, 能够达到的效果会更具有弹性, 但通常也需要更多的执行时间去产生一张图像. Ray tracing就是一种image order算法.</p>
<h2 id="4-1-The-Basic-Ray-Tracing-Algorithm"><a href="#4-1-The-Basic-Ray-Tracing-Algorithm" class="headerlink" title="4.1 The Basic Ray-Tracing Algorithm"></a>4.1 The Basic Ray-Tracing Algorithm</h2><p>Ray tracer每次计算一个像素, 而每个像素的任务是找到从这个像素出发, 所能”看到”的物体, 在确定了这一物体后, 根据合适的着色模型决定这一像素的最终值, 基于这样的原理, 可以将ray tracer的工作流程分为三步:</p>
<ol>
<li>ray generation: 计算通过每个像素的视线(viewing ray), 其出发点与方向.</li>
<li>ray intersection: 对每条实现, 找到与该视线相交的最近物体</li>
<li>shading: 基于相交检测的结果, 决定最终该像素的颜色</li>
</ol>
<h2 id="4-2-Perspective"><a href="#4-2-Perspective" class="headerlink" title="4.2 Perspective"></a>4.2 Perspective</h2><p>我们首先需要思考将3D场景转换为2D图像的方式, 大多数摄影, 美术所遵循的原则是: linear perspective，简单来说，在场景中的直线，在投影到2D平面时，需要依然为直线。</p>
<p>最简单的投影方式是平行投影，从图中很容易看出这种方式的特点：将物体延一定方向运动直至接触到投影平面，以此决定看到的景象，而投影的方向与平面是否垂直，则决定了是正投影(orthographic)还是斜投影(oblique)。如下图，展示了两种正投影的方法：</p>
<p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled.png" srcset="/myBlog.github.io/img/loading.gif" lazyload alt="Untitled.png"></p>
<p>平行投影的特点是：场景中互相平行的两条直线，在投影面中依然平行，因此常被用在工业设计上，但这种方式却与我们的眼睛观察世界的方式不同，眼睛与相机，透过一个特定的视点观察场景，而并不是从单一固定的视线方向接收光线的！这种方式即为透视投影，如下图所示：</p>
<p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled1.png" srcset="/myBlog.github.io/img/loading.gif" lazyload alt="Untitled1.png"></p>
<p>所有的视线均会穿过同一个点，即viewport，而非互相平行。有关透视投影的另一个有趣之处在于，原场景中的每组平行线，最后均会相交于同一个点，即vanishing point：</p>
<p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled2.png" srcset="/myBlog.github.io/img/loading.gif" lazyload alt="Untitled2.png"></p>
<p>很显然，离视点越远，物体将会越小。</p>
<h2 id="4-3-Computing-Viewing-Rays"><a href="#4-3-Computing-Viewing-Rays" class="headerlink" title="4.3 Computing Viewing Rays"></a>4.3 Computing Viewing Rays</h2><p>仔细想想，我们有了场景，我们确定了场景如何投影到平面上的方法，现在可以计算每条经过像素的视线了！首先需要确定的是viewport的位置(或是观察方向，对于平行投影而言)，以及投影的平面。</p>
<p>首先确定光线/视线(至少在本章，它们的意义都差不多)的数学表达形式：</p>
<p>$$\pmb{p}(t) = \pmb{e} + t(\pmb{s}-\pmb{e})$$</p>
<p>粗体表示一个三维向量。各向量的意义如下图所示：</p>
<p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled3.png" srcset="/myBlog.github.io/img/loading.gif" lazyload alt="Untitled3.png"></p>
<p>参数t确定了光线中的某个点。各个向量则在相机参考系(camera frame)中确定。</p>
<h3 id="4-3-1-Orthographic-Views"><a href="#4-3-1-Orthographic-Views" class="headerlink" title="4.3.1 Orthographic Views"></a>4.3.1 Orthographic Views</h3><p>在相机参考系w，u，v中考虑问题，所有视线都具有$-\pmb{w}$的方向。</p>
<p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled4.png" srcset="/myBlog.github.io/img/loading.gif" lazyload alt="Untitled4.png"></p>
<p>接下来定义图像平面，用$l&lt;0&lt;r, b&lt;0&lt;t$来定义图像的左右，上下范围。我们假设图像具有的像素数为$n_x \times n_y$，经过简单的数学运算，可以确定在光栅化图像的位置为<code>(i,j)</code>的像素点，其在相机坐标系中的位置为：</p>
<p>$$u = l+(r-l)(i+0.5)/n_x  \ v = b+(t-b)(j+0.5)/n_y$$</p>
<p>至此，不需要再进行多余工作，对正交投影而言，生成光线的流程是：</p>
<ol>
<li>对<code>(i,j)</code> 计算相应u，v</li>
<li>确定光线方向为$-\pmb{w}$</li>
<li>确定光线起点为$\pmb{e} + u\pmb{u} + v\pmb{v}$</li>
</ol>
<p>参考图如下：</p>
<p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled5.png" srcset="/myBlog.github.io/img/loading.gif" lazyload alt="Untitled5.png"></p>
<p>当然，这里的流程并没有考虑平行投影中斜投影的情况，仅仅是正交投影。</p>
<h3 id="4-3-2-Perspective-Views"><a href="#4-3-2-Perspective-Views" class="headerlink" title="4.3.2 Perspective Views"></a>4.3.2 Perspective Views</h3><p>来考虑另一种情况：透视投影，即所有光线的发射点为同一个点viewport，而每条光线的方向不同。</p>
<p>同样参考上图，以下的生成光线的流程是显然的：</p>
<ol>
<li>对<code>(i,j)</code> 计算相应u，v</li>
<li>确定光线方向为$-d\pmb{w}+u\pmb{u}+v\pmb{v}$</li>
<li>确定光线起点为$\pmb{e}$</li>
</ol>
<p>同样地，斜透视投影(即viewport和图像中心连线与图像平面不垂直)中，只需要修改$-d\pmb{w}$为$d\pmb{d}$即可。</p>
<h2 id="4-4-Ray-Object-Intersection"><a href="#4-4-Ray-Object-Intersection" class="headerlink" title="4.4 Ray-Object Intersection"></a>4.4 Ray-Object Intersection</h2><p>依前所述，无论是平行投影还是透视投影，我们都可以对每一个像素生成相应光线$\pmb{e}+t\pmb{d}$，接下来需要寻找这条光线与场景中最近物体的交点(t&gt;0)。</p>
<h3 id="4-4-1-Ray-Sphere-Intersection"><a href="#4-4-1-Ray-Sphere-Intersection" class="headerlink" title="4.4.1 Ray-Sphere Intersection"></a>4.4.1 Ray-Sphere Intersection</h3><p>依前，光线有表达式：$\pmb{p}(t)=\pmb{e}+t\pmb{d}$，而物体表面的隐式表达式为：$f(\pmb{p}) = 0$，当下式有t&gt;0的解时，光线与该物体相交：</p>
<p>$$f(\pmb{p}(t)) = 0$$</p>
<p>如果把球体上的点定义为p，而圆心为c，球体应有表达式：</p>
<p>$$(\pmb{p}-\pmb{c})(\pmb{p}-\pmb{c})-R^2=0$$</p>
<p>将光线p(t)代入上式求解即可：</p>
<p>$$(\pmb{e}+t\pmb{d}-\pmb{c})(\pmb{e}+t\pmb{d}-\pmb{c})-R^2 = 0$$</p>
<p>问题转换为求解关于t的一元二次方程，不再赘述。另两个有用的数学式为：</p>
<ul>
<li>某点p法向量：$\pmb{n}=2(\pmb{p}-\pmb{c})$</li>
<li>某点p单位法向量：$(\pmb{p}-\pmb{c})/R$</li>
</ul>
<h3 id="4-4-3-Ray-Triangle-Intersection"><a href="#4-4-3-Ray-Triangle-Intersection" class="headerlink" title="4.4.3 Ray-Triangle Intersection"></a>4.4.3 Ray-Triangle Intersection</h3><p>要解决与三角形的相交问题，先来考虑与平面的相交问题。正如直线可以由含一个参数t的表达式表示一样，平面可以由含两个参数u，v的表达式$\pmb{f}(u,v)$表示，故有：</p>
<p>$$\pmb{e}+t\pmb{d}=\pmb{f}(u,v)\Leftarrow \begin{cases} x_e+tx_d=f(u,v) \ y_e+ty_d=g(u,v) \z_e+tz_d=h(u,v) \end{cases}$$</p>
<p>此三元方程可解即表示有交点。接下来讨论是否交点在三角形的内部，假设其三个顶点为a，b，c。可以利用如下方程：</p>
<p>$$\pmb{e}+t\pmb{d} = \pmb{a}+\beta(\pmb{b}-\pmb{a}) + \gamma(\pmb{c}-\pmb{a})$$</p>
<p>其中，$t,\beta,\gamma$均可解，因为可以按照同样的方式将上式拓展为三元方程，若交点在三角形内，应有解：$\beta&gt;0, \gamma&gt;0, \beta+\gamma&lt;1$。若无解，可能光线平行于平面，或者三个顶点无法形成三角形。利用Cramer’s rule，可以直接求得上式的解。解的表达式见下，太长不想打：</p>
<p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled6.png" srcset="/myBlog.github.io/img/loading.gif" lazyload alt="Untitled6.png"></p>
<p>综上，我们可以发展起来一个判断在指定$[t_0,t_1]$范围内的光线与指定三角形是否有交点的算法，胡乱写的伪代码如下，几次判断可以减少运算的次数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">raytri</span><span class="hljs-params">(ray r, vector3 a, vector3 b, vector3 c, interval[t_0,t_1])</span></span>&#123;<br>	compute t<br>	<span class="hljs-keyword">if</span> (t&lt;t_0) || (t&gt;t_1) then<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>	compute gamma<br>	<span class="hljs-keyword">if</span>(gamma&lt;<span class="hljs-number">0</span>) || (gamma&gt;<span class="hljs-number">1</span>) then<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>	compute beta<br>	<span class="hljs-keyword">if</span>(beta&lt;<span class="hljs-number">0</span>) || (beta&gt;<span class="hljs-number">1</span>-gamma) then<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-4-3-Ray-Polygon-Intersection"><a href="#4-4-3-Ray-Polygon-Intersection" class="headerlink" title="4.4.3 Ray-Polygon Intersection"></a>4.4.3 Ray-Polygon Intersection</h3><p>更进一步，考虑与平面多边形的相交情况。该多边形有p_1至p_m共m个顶点，平面法向量为n，光线则有$\pmb{p}(t) = \pmb{e}+t\pmb{d}$，首先利用下式计算与平面的交点：</p>
<p>$$(\pmb{p}-\pmb{p}_1)\cdot \pmb{n}=0$$</p>
<p>可得解为：</p>
<p>$$t = \frac{(\pmb{p}_1-\pmb{e})\cdot \pmb{n}}{\pmb{d}\cdot \pmb{n}}$$</p>
<p>接下来即判断由t得到的交点p是否在多边形内。</p>
<p>基本的想法是从该交点p放出一条射线，计算射线与多边形的交点个数，若个数为奇数，则在内部，否则在外部。通常的简化方法是将多边形与点都映射到一个平面上再进行计算，这样要简便一些。我们此处没有考虑更多特殊情况，如交点恰好为顶点，或是射线在顶点与多边形相交等。</p>
<p>当然，我们总是可以将多边形分割为多个三角形之后再行判断。</p>
<h3 id="4-4-4-Intersecting-a-Group-of-Objects"><a href="#4-4-4-Intersecting-a-Group-of-Objects" class="headerlink" title="4.4.4 Intersecting a Group of Objects"></a>4.4.4 Intersecting a Group of Objects</h3><p>在解决了上述问题后，我们可以来谈谈更实际的情景：判断和一组物体的相交，关键之处在于，在给定初始区间[t_0, t_1]中，找到最近的交点，伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">hit = <span class="hljs-literal">false</span><br><span class="hljs-keyword">for</span> each object o in group <span class="hljs-keyword">do</span><br>	<span class="hljs-keyword">if</span>(o is hit at ray parameter t <span class="hljs-keyword">and</span> t&gt;t_0 <span class="hljs-keyword">and</span> t&lt;t_1) then<br>		hit = <span class="hljs-literal">true</span><br>		hitobject = o<br>		t_1 = t<br><span class="hljs-keyword">return</span> hit<br></code></pre></td></tr></table></figure>

<h2 id="4-5-Shading"><a href="#4-5-Shading" class="headerlink" title="4.5 Shading"></a>4.5 Shading</h2><p>当一个像素所对应的物体表面被确定之后，我们需要决定采用的着色(shading)模型来为该像素赋值。本章讨论最简单的两种着色模型。</p>
<h3 id="4-5-1-Lambertian-Shading"><a href="#4-5-1-Lambertian-Shading" class="headerlink" title="4.5.1 Lambertian Shading"></a>4.5.1 Lambertian Shading</h3><p>最简单的着色模型当属Lambert所设计的模型：光源发射到某一表面的能量取决于光线与该表面的夹角：</p>
<p>$$L = k_dImax(0, \pmb{n\cdot l})$$</p>
<p>L为该像素的颜色，k_d则是该表面的漫反射系数，也可以理解为表面颜色，I为光源亮度，两个向量的含义如下图所示：</p>
<p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled7.png" srcset="/myBlog.github.io/img/loading.gif" lazyload alt="Untitled7.png"></p>
<p>这里利用点乘获取夹角的余弦值，同时要注意向量需为单位向量。</p>
<h3 id="4-5-2-Blinn-Phong-Shading"><a href="#4-5-2-Blinn-Phong-Shading" class="headerlink" title="4.5.2 Blinn-Phong Shading"></a>4.5.2 Blinn-Phong Shading</h3><p>Lambertian模型是独立于视角的，即从哪个方向看并不影响看到的颜色，这也是漫反射的特点，没有考虑到镜面反射。</p>
<p>Blinn-Phong模型是基于这样的想法：当视线$\pmb{v}$与光线$\pmb{l}$相对于表面法向量对称分布时，将会观察到较强的反射光。为了计算两个向量分布的对称程度，引入半程向量h(half vector)，即两向量角平分线上的单位向量，用h与平面法向量的夹角衡量对称程度，夹角越小，则越对称。</p>
<p>Blinn-Phong模型确定了镜面反射的计算方法，与Lambertian结合起来，有如下形式：</p>
<p>$$\pmb{h} = \frac{\pmb{v}+\pmb{l}}{|\pmb{v}+\pmb{l}|} \ L=k_dImax(0, \pmb{n\cdot l}) + k_sImax(0,\pmb{n\cdot h})^p$$</p>
<p>p即Phong指数，用来控制表面的镜面反射程度，当p较大时，镜面反射的光强将在视线远离对称位置后迅速衰减。k_s则为镜面反射系数。</p>
<p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled8.png" srcset="/myBlog.github.io/img/loading.gif" lazyload alt="Untitled8.png"></p>
<h3 id="4-5-3-Ambient-Shading"><a href="#4-5-3-Ambient-Shading" class="headerlink" title="4.5.3 Ambient Shading"></a>4.5.3 Ambient Shading</h3><p>在考虑过镜面反射与漫反射之后，我们的模型仍有一个缺点：那些无法被光源直接照射到的区域将会完全漆黑，而这是非常不合常理的！事实上，因为多次反射的存在，那些没有被直接照射的区域依然能被微弱的环境光照亮，基于此，我们为所有的像素值都加上一个随表面特性而改变的特定值：</p>
<p>$$L=k_aI_a + k_dImax(0, \pmb{n\cdot l}) + k_sImax(0,\pmb{n\cdot h})^p$$</p>
<p>k_a代表表面的环境光系数(ambient coefficient)，I_a则表示环境光强度。</p>
<h3 id="4-5-4-Multiple-Point-Lights"><a href="#4-5-4-Multiple-Point-Lights" class="headerlink" title="4.5.4 Multiple Point Lights"></a>4.5.4 Multiple Point Lights</h3><p>多个光源的情况亦很简单，无非是多个漫反射，镜面反射的强度叠加。而注意，环境光分量并不需要改变：其本身就是复杂的光照叠加的近似结果，假设我们有N个光源：</p>
<p>$$L=k_aI_a + \sum_{i=1}^N[k_dI_imax(0, \pmb{n\cdot l_i}) + k_sI_imax(0,\pmb{n\cdot h_i})^p]$$</p>
<h2 id="4-6-A-Ray-Tracing-Program"><a href="#4-6-A-Ray-Tracing-Program" class="headerlink" title="4.6 A Ray-Tracing Program"></a>4.6 A Ray-Tracing Program</h2><p>基于此前的讨论，我们现在应该清楚，光线是如何从特定像素中射出，如何检测光线与物体平面的交点，又如何基于检测结果对像素点进行着色，是时候动手写一个完整的程序了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> each pixel <span class="hljs-keyword">do</span>:<br>	compute viewing ray based on projection method<br>	<span class="hljs-keyword">if</span> ray intersect with object with t&gt;<span class="hljs-number">0</span> then<br>		compute normal vector n<br>		compute <span class="hljs-keyword">and</span> set pixel value based on shading model<br>	<span class="hljs-keyword">else</span><br>		set pixel value to background color<br></code></pre></td></tr></table></figure>

<h3 id="4-6-1-Object-Oriented-Design-for-a-Ray-Tracing-Program"><a href="#4-6-1-Object-Oriented-Design-for-a-Ray-Tracing-Program" class="headerlink" title="4.6.1 Object-Oriented Design for a Ray-Tracing Program"></a>4.6.1 Object-Oriented Design for a Ray-Tracing Program</h3><p>这里不太好懂。。只是讲编程的思想而非实践。</p>
<p>总的来说，所有能被光线检测到碰撞的物体都应被定义为surface或其子类，这一基类/抽象类的行为如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">surface</span></span><br><span class="hljs-class">	<span class="hljs-title">virtual</span> <span class="hljs-title">bool</span> <span class="hljs-title">hit</span>(<span class="hljs-title">ray</span> <span class="hljs-title">e</span>+<span class="hljs-title">td</span>, <span class="hljs-title">real</span> <span class="hljs-title">t_0</span>, <span class="hljs-title">real</span> <span class="hljs-title">t_1</span>, <span class="hljs-title">hit</span>-<span class="hljs-title">record</span> <span class="hljs-title">rec</span>)</span><br><span class="hljs-class">	<span class="hljs-title">virtual</span> <span class="hljs-title">box</span> <span class="hljs-title">bounding</span>-<span class="hljs-title">box</span>()</span><br></code></pre></td></tr></table></figure>

<p>rec是一个用于返回的引用参数，返回如相交时的t值等。</p>
<h2 id="4-7-Shadows"><a href="#4-7-Shadows" class="headerlink" title="4.7 Shadows"></a>4.7 Shadows</h2><p>在如前所述的框架下，要考虑阴影是简单的。当检测到碰撞后，我们可以从返回的信息中得到光线向量$\pmb{l}$，此时的碰撞点亦已知，那么，只要我们从该碰撞点向光源方向“望去”，或者说发出一条射线并在遇到光源前检测到与其他物体的碰撞，说明此处为阴影，否则可以被照射。</p>
<p>不同于viewing ray，此处放出的射线，我们定义为shadow ray。如下图所示，还有一个要注意的问题是，我们的shadow ray可能因为数值计算的精度关系，检测到与p点所在的平面的相交情况！为了避免这种错误，我们常常设置一个极小值$\varepsilon$：</p>
<p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled9.png" srcset="/myBlog.github.io/img/loading.gif" lazyload alt="Untitled9.png"></p>
<p>于是，借助此前的hit函数，我们可以定义完整的返回pixel color的函数，详见p86：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">function <span class="hljs-title">raycolor</span><span class="hljs-params">(ray e+td, real t_0, real t_1)</span></span><br>	hit-record rec, srec<br>	<span class="hljs-comment">//检测到与某物体表面相交</span><br>	<span class="hljs-keyword">if</span>(scene-&gt;<span class="hljs-built_in">hit</span>(ray, t_0, t_1, rec)) then<br>		<span class="hljs-comment">//计算相交位置</span><br>		p = e + rec.t*d<br>		<span class="hljs-comment">//计算环境光分量</span><br>		color c = rec.k_a*I_a<br>		<span class="hljs-comment">//检测碰撞</span><br>		<span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> scene-&gt;<span class="hljs-built_in">hit</span>(p+sl, epsilon, infinite, srec)) then<br>			calculate vector3 h = <span class="hljs-built_in">normalized</span>(l + (-d))<br>			c = c + rec.k_d*I*<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, rec.n*l) + rec.k_s*I*<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, rec.n*h)^(rec.p)<br>		<span class="hljs-keyword">return</span> c<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span> background-color<br></code></pre></td></tr></table></figure>

<h2 id="4-8-Ideal-Specular-Reflection"><a href="#4-8-Ideal-Specular-Reflection" class="headerlink" title="4.8 Ideal Specular Reflection"></a>4.8 Ideal Specular Reflection</h2><p>为了更为真实的镜面反射效果，我们可以模拟一面镜子的效果，这需要我们在与镜子的交点处再发出一条对称的视线，如下图所示：</p>
<p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled10.png" srcset="/myBlog.github.io/img/loading.gif" lazyload alt="Untitled10.png"></p>
<p>向量r可由下式得到：</p>
<p>$$\pmb{r} = \pmb{d} - 2(\pmb{d\cdot n})\pmb{n}$$</p>
<p>借助于此前所函数raycolor，我们需要清楚这一函数完成了什么工作：在指定的相机参考系中，放出一条光线，并返回应该得到的着色值，我们只需要将这条放出的光线替换为r即可，最终的着色值为<code>color c = c + k_m*raycolor(p+sr, epsilon, infinite)</code> ，其中的k_m代表着反射镜面的系数，p为镜面上的相交点，取区间为$[\varepsilon, \infty)$的意义与shadow ray一致：防止检测到与镜面本身的碰撞。</p>
<p>当然，为了防止这一递归式无尽地计算(这一情况还是比较常见的，就比如把两块镜子摆在一起)。通常的解决方案是设定一个最大的递归深度(但是到递归深度以后的默认值该如何选取？不懂)</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter2%20Miscellaneous%20Math/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Fundamental of CG研习：Chapter2 Miscellaneous Math</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter3%20Raster%20Images/">
                        <span class="hidden-mobile">Fundamental of CG研习：Chapter3 Raster Images</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/myBlog.github.io/js/events.js" ></script>
<script  src="/myBlog.github.io/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/myBlog.github.io/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/myBlog.github.io/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/myBlog.github.io/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/myBlog.github.io/js/boot.js" ></script>


</body>
</html>
