<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Fundamental of CG研习：Chapter5 Linear Algebra</title>
    <link href="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/"/>
    <url>/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/</url>
    
    <content type="html"><![CDATA[<h1 id="5-Linear-Algebra"><a href="#5-Linear-Algebra" class="headerlink" title="5 Linear Algebra"></a>5 Linear Algebra</h1><p>本章讨论线性代数。</p><p>在图形程序中应用最广泛的大概就是用来改变或者变换点，向量的矩阵了。在下章我们将会介绍一个向量如何被表示为一个单列矩阵，一个向量如何利用矩阵完成在不同基底下的变换，以及一些基本变化如方所，旋转，平移等。本章则讨论这些内容的数学基础——线性代数。</p><h2 id="5-1-Determinants"><a href="#5-1-Determinants" class="headerlink" title="5.1 Determinants"></a>5.1 Determinants</h2><p>向量组成的行列式(determinant)可以具有面积或体积的含义。例如二维向量$\pmb{a, b}$，有$|\pmb{ab}|$即表示由这两个向量构成的平行四边形的面积，有：</p><p>$$|\pmb{ab}| = \left|<br>\begin{array}{}<br>    a_1  &amp;  b_1 \<br>   a_2  &amp;  b_2<br>\end{array}<br>\right|<br>$$</p><p>行列式有符号之分，如果在右手系中，a→b指向的方向为正向，则计算结果亦为正，若指向方向为负向，则结果亦为负，自然地，有$|\pmb{ab}| = -|\pmb{ba}|$，推广到三维，行列式$|\pmb{abc}|$需要由三个向量构成，此时的正负意义似乎不大清楚。。</p><p>从二维出发，有以下运算性质，从行列式的几何意义十分容易导出：</p><p>$$|(k\pmb{a})\pmb{b}| = |\pmb{a}(k\pmb{b})| = k |\pmb{ab}| \ $$</p><p>加上平行的向量不影响计算结果：</p><p>$$|(\pmb{a}+k\pmb{b})\pmb{b}| = |\pmb{a}(\pmb{b}+k\pmb{a})| = |\pmb{ab}|$$</p><p>这一结果的原因可由下图清楚地展示：</p><p><img src="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/Untitled.png" alt="Untitled.png"></p><p>分配律：</p><p>$$|\pmb{a}(\pmb{b}+\pmb{c})| = |\pmb{ab}| + |\pmb{ac}|$$</p><p>无需证明，由下图可知：</p><p><img src="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/Untitled1.png" alt="Untitled1.png"></p><p>利用如上所述的向量行列式运算性质，可以导出行列式的计算公式：</p><p><img src="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/Untitled2.png" alt="Untitled2.png"></p><p>同样，相同的运算方法可以被用来计算三维行列式：</p><p><img src="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/Untitled3.png" alt="Untitled3.png"></p><p>可以利用这些性质完成一些计算的目标，例如，我们希望利用基底$\pmb{}$$\pmb{a},\pmb{b}$表示一个向量$\pmb{c}$：</p><p>$$\pmb{c} = a_c\pmb{a}+b_c\pmb{b}$$</p><p>那么有：</p><p>$$|\pmb{ca}| = |(a_c\pmb{a}+b_c\pmb{b})\pmb{a}|=|(b_c\pmb{b})\pmb{a}| = b_c|\pmb{b}\pmb{a}|$$</p><p>即：</p><p>$$b_c = \frac{|\pmb{ca}|}{|\pmb{ba}|}, a_c = \frac{|\pmb{bc}|}{|\pmb{ba}|}$$</p><p>这是一个简单的例子，展示运算律的作用。</p><h2 id="5-2-Matrices"><a href="#5-2-Matrices" class="headerlink" title="5.2 Matrices"></a>5.2 Matrices</h2><p>矩阵经常被用于空间的变换，本章涉及的矩阵元素均为实数。</p><h3 id="5-2-1-Matrix-Arithmetic"><a href="#5-2-1-Matrix-Arithmetic" class="headerlink" title="5.2.1 Matrix Arithmetic"></a>5.2.1 Matrix Arithmetic</h3><p>矩阵的数乘，乘法，加法这里略去不讲。乘法要求左边矩阵的列数等于右边矩阵的行数，且不可交换。$\pmb{AB} = \pmb{AC}$亦无法推出$\pmb{B} = \pmb{C}$，但有如下性质：</p><p>$$(\pmb{AB})\pmb{C} = \pmb{A}(\pmb{BC}) \ \pmb{A}(\pmb{B}+\pmb{C}) = \pmb{AB} + \pmb{AC} \ (\pmb{A+B})\pmb{C}=\pmb{AC}+\pmb{BC}$$</p><h3 id="5-2-2-Operations-on-Matrices"><a href="#5-2-2-Operations-on-Matrices" class="headerlink" title="5.2.2 Operations on Matrices"></a>5.2.2 Operations on Matrices</h3><p>在矩阵运算中，对角线上元素为1其余为0的方阵称为单位矩阵(identity matrices)，代表“1”。逆矩阵有性质：</p><p>$$\pmb{AA}^{-1} = \pmb{I} \ (\pmb{AB})^{-1} = \pmb{B}^{-1}\pmb{A}^{-1}$$</p><p>对转置矩阵，有：</p><p>$$(\pmb{AB})^{T} = \pmb{B}^{T}\pmb{A}^{T}$$</p><p>方阵的行列式有如下性质：</p><p>$$|\pmb{AB}|=|\pmb{A}||\pmb{B}| \ |\pmb{A}^{-1}||\pmb{A}|=1 \ |\pmb{A}^T| = |\pmb{A}|$$</p><h3 id="5-2-3-Vector-Operations-in-Matrix-Form"><a href="#5-2-3-Vector-Operations-in-Matrix-Form" class="headerlink" title="5.2.3 Vector Operations in Matrix Form"></a>5.2.3 Vector Operations in Matrix Form</h3><p>我们尝试用矩阵去变换向量，通常的流行的做法是将向量表达成一个一列的矩阵，去右乘(postmultiplication)一个变换矩阵，如下所示，将一个向量旋转了90度：</p><p>$$\left[<br>\begin{array}{cc}<br>    0  &amp;  -1  \<br>    1  &amp;  0<br>\end{array}<br>\right] \left[<br>\begin{array}{cc}<br>    x_a   \<br>    y_a<br>\end{array}<br>\right]=\left[<br>\begin{array}{cc}<br> -y_a\<br> x_a<br>\end{array}<br>\right]$$</p><p>如果把标量的视为1*1的矩阵，那么向量的点积可以写成矩阵的乘法：</p><p>$$\pmb{a\cdot b} = \pmb{a}^T\pmb{b}$$</p><p>同样地，外积，即叉乘也可以写成矩阵乘法：</p><p>$$\pmb{a\times b} = \pmb{a}\pmb{b}^T$$</p><p>但是，叉乘的结果应该是一个同维度的向量？该怎么理解这里的计算结果？</p><h3 id="5-2-4-Special-Types-of-Matrices"><a href="#5-2-4-Special-Types-of-Matrices" class="headerlink" title="5.2.4 Special Types of Matrices"></a>5.2.4 Special Types of Matrices</h3><p>本节介绍了一些用到的特殊矩阵：</p><ol><li>单位矩阵(identity matrix)，对角线元素均为1，其余为0.</li><li>对角矩阵(diagonal matrix)</li><li>正交矩阵(orthogonal matrix)，各列向量/各行向量互相正交，同时均为单位向量的矩阵。正交矩阵有重要性质：$\pmb{R}^T\pmb{R} = \pmb{R}\pmb{R}^T = \pmb{I}$，这样考虑问题：结果矩阵的对角线元素为原正交矩阵的两个单位向量的点乘结果，而非对角元素为两个正交单位向量的点乘结果，即为0。</li></ol><h2 id="5-3-Computing-with-Matrices-and-Determinants"><a href="#5-3-Computing-with-Matrices-and-Determinants" class="headerlink" title="5.3 Computing with Matrices and Determinants"></a>5.3 Computing with Matrices and Determinants</h2><p>将矩阵和行列式的知识结合起来化简行列式的计算。</p><p>回忆5.1节的内容，一个n维的行列式可以表示n个n维向量所构成的n维平行六面体的面积/体积。同时，因为行列式的性质：经过转置后其值保持不变，这意味着两组不同的n维向量可以形成相同体积的六面体，要说人话的话，见下面的式子：</p><p><img src="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/Untitled4.png" alt="Untitled4.png"></p><p>看到没有，左边行列式和右边所表示的两组向量是不同的，但其计算结果是一致的~</p><p>另一个好玩的例子在于，我们可以简便地利用行列式表示一个由三个点确定的平面：</p><p><img src="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/Untitled5.png" alt="Untitled5.png"></p><p>因为三个列向量在共面的情况下，形成的六面体自然为零。</p><p>按照定义计算行列式很累，可以利用拉普拉斯展开式进行计算，这需要用到行列式的余子式(cofactor)，举例来说比较形象：取n维行列式中的元素$a_{ij}$为例，$a_{ij}$的余子式就是原行列式去掉第i行第j列后形成的n-1维行列式，其符号由i+j决定，若为奇数则为负，偶数为正。</p><p>如何利用余子式得到行列式的值？选取任意一行或者列的所有元素计算元素与余子式的乘积之和即可，例如：</p><p><img src="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/Untitled6.png" alt="Untitled6.png"></p><p>此处，向量不线性独立，故结果为零。我们使用$a_{ij}^c$表示$a_{ij}$的余子式。</p><h3 id="5-3-1-Computing-Inverses"><a href="#5-3-1-Computing-Inverses" class="headerlink" title="5.3.1 Computing Inverses"></a>5.3.1 Computing Inverses</h3><p>可以利用余子式构建伴随矩阵(adjoint)去计算任意矩阵的逆矩阵。以4*4的矩阵为例，其逆矩阵有如下形式：</p><p><img src="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/Untitled7.png" alt="Untitled7.png"></p><p>当然，若其行列式为0，则该矩阵为奇异矩阵，不存在逆矩阵，在不为0的情况下我们讨论问题。这一结果看起来很奇怪，但仔细分析一下就好了，考虑原矩阵$\pmb{A}$与伴随矩阵的乘积，对于对角线上的元素，有：</p><p><img src="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/Untitled8.png" alt="Untitled8.png"></p><p>这恰好就是计算行列式$|\pmb{A}|$的拉普拉斯展开式，而对于非对角线元素，有：</p><p><img src="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/Untitled9.png" alt="Untitled9.png"></p><p>这一计算结果相当于我们计算下面这个奇异矩阵的行列式，因为两行相同，故其行列式必为0：</p><p><img src="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/Untitled10.png" alt="Untitled10.png"></p><p>一个利用伴随矩阵计算逆矩阵的例子如下：</p><p><img src="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/Untitled11.png" alt="Untitled11.png"></p><h3 id="5-3-2-Linear-Systems"><a href="#5-3-2-Linear-Systems" class="headerlink" title="5.3.2 Linear Systems"></a>5.3.2 Linear Systems</h3><p>本节介绍利用克莱姆法则(Cramer’s rule)解决在图形程序中常遇到的三元/四元方程问题。只需要知道如何使用就好，例如，我们需要解决下面的式子所代表的方程：</p><p><img src="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/Untitled12.png" alt="Untitled12.png"></p><p>可以抽象为$\pmb{Ax} = \pmb{b}$，其解为：</p><p><img src="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/Untitled13.png" alt="Untitled13.png"></p><p>注意到解的分母均为$|\pmb{A}|$，而分子则是将待解未知元按照其位置将对应列替换为$\pmb{b}$的行列式，若$|\pmb{A}|=0$，则方程将无解。</p><h2 id="5-4-Eigenvalues-and-Matrix-Diagonalization"><a href="#5-4-Eigenvalues-and-Matrix-Diagonalization" class="headerlink" title="5.4 Eigenvalues and Matrix Diagonalization"></a>5.4 Eigenvalues and Matrix Diagonalization</h2><p>本节介绍特征值与矩阵对角化。本章的内容较为抽象一些，不过仔细写一写是有好处的。</p><p>每个方阵都具有对应的特征值(eigenvalues)和特征向量(eigenvectors)、特征向量的定义如下：</p><p>$$\pmb{Aa} = \lambda\pmb{a}$$</p><p>即该向量与矩阵相乘的结果就是这个向量的伸缩运算。我们可以做如下运算去求解特征值与特征向量，有：</p><p>$$\pmb{Aa} = \lambda\pmb{Ia} \ \pmb{Aa}-\lambda\pmb{Ia}=0 \ (\pmb{A}-\lambda\pmb{I})\pmb{a}=0$$</p><p>由之前所介绍的克莱姆法则，若左边的矩阵$\pmb{A}-\lambda\pmb{I}$为非奇异矩阵，即方程存在唯一解——显然都是0，那么就没有意义了，因此，必有行列式$|\pmb{A}-\lambda\pmb{I}|$值为0，以2*2的矩阵为例，可以列出如下方程：</p><p><img src="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/Untitled14.png" alt="Untitled14.png"></p><p>该方程应有两个解，可能是两个相同的解，亦可能为复数解。要解这个方程，在n≤4的情况下可给出解析解，而n&gt;4时，我们只能给出数值解。</p><p>当矩阵为对称矩阵时，我们可以求得较为简单的特征值与特征向量。shi利用求解得到的特征值与特征向量，我们可以对原矩阵进行如下形式的特征值分解：</p><p>$$\pmb{A} = \pmb{QDQ}^T$$</p><p>其中，A为原矩阵，Q为以特征向量为列的矩阵，D为由特征值构成的对角矩阵。</p><p>实对称矩阵的特侦值总是实数，且若其特征值各不相同，那么各特征向量必然互相正交。利用这一性质，我们可以将较复杂的原实对称矩阵分解为正交矩阵，对角矩阵的连乘。以如下二维矩阵的运算为例：</p><p><img src="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/Untitled15.png" alt="Untitled15.png"></p><p>运算的过程不必赘述，看看运算的式子就好，需要注意的是，特征向量可以有无数个值，但这些值的方向都相同。</p><h3 id="5-4-1-Singular-Value-Decomposition"><a href="#5-4-1-Singular-Value-Decomposition" class="headerlink" title="5.4.1 Singular Value Decomposition"></a>5.4.1 Singular Value Decomposition</h3><p>前面所介绍的特征值分解有一定局限性——我们只能将其运用在实对称矩阵的分解上，因为一般矩阵的特征值可能是复数或是相同的，我们希望可以推广到任意的矩阵，这种方法被称为奇异值分解(singular value decomposition SVD)。其表达式如下：</p><p>$$\pmb{A} = \pmb{USV}^T$$</p><p>其中，U和V是两个不同的正交矩阵，其中的列向量分别被称为A的左/右奇异向量，S则是一个由A的奇异值所构成的对角矩阵。当A是一个对称矩阵且特征值均非负时，特征值分解和奇异值分解实际上是一回事。</p><p>为了求解奇异值，我们先构想一个矩阵$\pmb{M} = \pmb{AA}^T$，显然这一矩阵为对称矩阵，带入奇异值分解式，有：</p><p>$$\pmb{M} = \pmb{AA}^T = (\pmb{USV}^T)(\pmb{USV}^T)^T = \pmb{US}(\pmb{V}^T\pmb{V})\pmb{SU}^T=\pmb{US}^2\pmb{U}^T$$</p><p>以上运算利用了正交矩阵的性质，因为其逆矩阵即为正交矩阵本身的转置。这一式子的美妙之处在于我们得到了一个对称矩阵的特征值分解，于是，我们可以利用求解特征值的方法求解$\pmb{U},\pmb{S}$(注意开方时非负)。同样地，利用$\pmb{M} = \pmb{AA}^T$可以求出$\pmb{V}$。至此，就完成了任意矩阵的奇异值分解。</p><p>书中提供了一个计算的例子，以供参考：</p><p><img src="/myBlog.github.io/2021/07/23/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter5%20Linear%20Algebra/Untitled16.png" alt="Untitled16.png"></p><h2 id="常见的问题"><a href="#常见的问题" class="headerlink" title="常见的问题"></a>常见的问题</h2><p>为什么不用元素乘元素的方式定义矩阵相乘，而采用如此麻烦的乘法？</p><p>我们是基于运算的需要而定义矩阵乘法的，而非其计算是否符合我们的直觉。</p><p>后面的看不太懂。</p><p>为什么谈论奇异值与特征值的时候，我们一会说奇异值特征值是一回事，有时候会说奇异值是特征值的平方根？</p><p>两种陈述是在不同的情况下说明的。</p><p>当一个实矩阵对称且特征值非负时，其特征值与奇异值相同。</p><p>而就算一个矩阵A若不对称，$\pmb{M} = \pmb{AA}^T$也会是对称的，并且具有非负的实特征值，那么此时A和A的转置就具有相同的奇异值且为M的特征值开方，所以当我们说奇异值是特征值的平方根时，我们谈论的是两个不同的矩阵，$\pmb{M} = \pmb{AA}^T$与$\pmb{A}$。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fundamental of CG研习：Chapter1 Introduction</title>
    <link href="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter1%20Introduction/"/>
    <url>/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter1%20Introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><h2 id="1-1-Graphics-Area"><a href="#1-1-Graphics-Area" class="headerlink" title="1.1 Graphics Area"></a>1.1 Graphics Area</h2><p>图形学领域的研究问题大体上可以分为三块：</p><ol><li>Modeling，处理在计算机中存储，表示物体的方法，包括其形状，外观特性等。如物体的点坐标，反射模型。</li><li>Rendering，利用model提供的信息将场景渲染为图像</li><li>Animation，关注使用前两者呈现动态效果的问题。</li></ol><h2 id="1-3-Graphics-APIs"><a href="#1-3-Graphics-APIs" class="headerlink" title="1.3 Graphics APIs"></a>1.3 Graphics APIs</h2><p>图形API负责绘制图像并映射至屏幕中。有两大类：Java，Direct3D与OpenGL。</p><h2 id="1-4-Graphics-Pipeline"><a href="#1-4-Graphics-Pipeline" class="headerlink" title="1.4 Graphics Pipeline"></a>1.4 Graphics Pipeline</h2><p>图形流水线被用于绘制透视图中的3D原语。</p><p>场景中的三角形数量很大程度上影响了图像的生成速度，我们可以使用level of detail，即LOD决定该以何种等级展示model的细节，从而控制三角形面片的数量。</p><h2 id="1-5-Numerical-Issues"><a href="#1-5-Numerical-Issues" class="headerlink" title="1.5 Numerical Issues"></a>1.5 Numerical Issues</h2><p>图形渲染的计算过程中，一些数值问题不可忽视，以浮点数为例，通行的标准IEEE-floating-point提供了一下几个特殊值：为程序提供了方便：</p><p>$$\infty ,-\infty ,NaN$$</p><p>这些特殊值在处理除零错误，避免程序因一些特殊情况而崩溃时十分有用，详见p6-7</p><h2 id="1-6-Efficiency"><a href="#1-6-Efficiency" class="headerlink" title="1.6 Efficiency"></a>1.6 Efficiency</h2><p>为了提高代码的效率，一些准则值得被采纳。例如，相较于处理器计算能力的增长，内存的访问速度增速缓慢，这意味着我们更应该关注减少内存访问，而非指令的执行次数，可以改善性能的方法包括：</p><ul><li>避免存储计算中间结果，而直接书写为一行代码，尽管这意味着可读性的下降</li><li>在优化模式下编译</li><li>尝试使用分析工具找到代码瓶颈，即决定运行速度的关键部分</li><li>以可能的方式修改数据结构使之契合设备的缓存，页的尺寸</li><li>检查生成的汇编文件以寻找改善空间</li></ul><p>还需要注意的是，有时不必遵循一些古老的建议，例如，当今的CPU可以以相同的速度处理浮点数和整型数，而不必刻意避免浮点数的使用。</p><h2 id="1-7-Designing-and-Coding-Graphics-Programs"><a href="#1-7-Designing-and-Coding-Graphics-Programs" class="headerlink" title="1.7 Designing and Coding Graphics Programs"></a>1.7 Designing and Coding Graphics Programs</h2><p>良好的图形程序需要有良好的类与例程以表示集合实体，例如向量，矩阵，RGB值等。</p><p>为了减少内存的使用，我们当然希望使用空间小的float而非double。但为了避免可能的数值问题，我们又需要使用double而非float，tradeoffs depend on the program。一个建议是全部使用float，直到出现问题时，才将必要的部分变为double。</p><p>以下的几个针对图形程序的调试建议是有用的：</p><ul><li><p>The Scientific Method</p><p>  关闭，启用一些可能存在问题的元素如光照，阴影，有时候就能找到问题</p></li><li><p>Images as Coded Debugging Output</p><p>  以图像的方式显示一些关键信息，例如，把每个顶点的法向量值作为一张图像的输入，这样显然可以非常直观的发现这些被映射为图像的数据可能存在的问题</p></li><li><p>Using a Debugger</p><p>  图形渲染常常意味着同一指令的重复执行，借由崩溃信息，我们或许可以知道是哪一行有问题，但却很难发现是哪一次执行出现了问题，修改代码以使其在怀疑的地方触发break point十分有用。同时，我印象中Visual Studio也提供了条件端点这一功能，这避免了我们对代码的修改。如下，我们怀疑在(126,247)这一处出了问题：</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic">if x==126 and y==247 then:<br>print &quot;blarg!&quot;<br></code></pre></td></tr></table></figure></li><li><p>Data Visualization for Debugging</p><p>  尝试去可视化程序的中间状态，或许可以发现问题</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fundamental of CG研习：Chapter2 Miscellaneous Math</title>
    <link href="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter2%20Miscellaneous%20Math/"/>
    <url>/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter2%20Miscellaneous%20Math/</url>
    
    <content type="html"><![CDATA[<h1 id="2-Miscellaneous-Math"><a href="#2-Miscellaneous-Math" class="headerlink" title="2 Miscellaneous Math"></a>2 Miscellaneous Math</h1><p>这一章的主要内容在于介绍各种图形学中使用到的数学知识，大部分都已经学过，在要使用到时再行补充。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fundamental of CG研习：Chapter4 Ray Tracing</title>
    <link href="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/"/>
    <url>/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/</url>
    
    <content type="html"><![CDATA[<h1 id="4-Ray-Tracing"><a href="#4-Ray-Tracing" class="headerlink" title="4 Ray Tracing"></a>4 Ray Tracing</h1><p>本章讨论光线追踪技术. </p><p>基本上, 渲染是一个将一系列物体, 场景的布置作为输入, 并输出相应的像素阵列的过程.而渲染亦可分为两类: object-order rendering与image-order rendering. </p><ul><li>object-order rendering按顺序考虑要渲染的每个物体, 每当考虑一个物体时, 更新与这一物体有关联的所有像素点.</li><li>image-order rendering则按顺序考虑每个像素点并计算这一像素的最终值, 因此在计算时, 需要考虑所有可能影响这一像素值的物体.</li></ul><p>宽泛地讲, image-order rendering的工作原理会更简单, 能够达到的效果会更具有弹性, 但通常也需要更多的执行时间去产生一张图像. Ray tracing就是一种image order算法.</p><h2 id="4-1-The-Basic-Ray-Tracing-Algorithm"><a href="#4-1-The-Basic-Ray-Tracing-Algorithm" class="headerlink" title="4.1 The Basic Ray-Tracing Algorithm"></a>4.1 The Basic Ray-Tracing Algorithm</h2><p>Ray tracer每次计算一个像素, 而每个像素的任务是找到从这个像素出发, 所能”看到”的物体, 在确定了这一物体后, 根据合适的着色模型决定这一像素的最终值, 基于这样的原理, 可以将ray tracer的工作流程分为三步:</p><ol><li>ray generation: 计算通过每个像素的视线(viewing ray), 其出发点与方向.</li><li>ray intersection: 对每条实现, 找到与该视线相交的最近物体</li><li>shading: 基于相交检测的结果, 决定最终该像素的颜色</li></ol><h2 id="4-2-Perspective"><a href="#4-2-Perspective" class="headerlink" title="4.2 Perspective"></a>4.2 Perspective</h2><p>我们首先需要思考将3D场景转换为2D图像的方式, 大多数摄影, 美术所遵循的原则是: linear perspective，简单来说，在场景中的直线，在投影到2D平面时，需要依然为直线。</p><p>最简单的投影方式是平行投影，从图中很容易看出这种方式的特点：将物体延一定方向运动直至接触到投影平面，以此决定看到的景象，而投影的方向与平面是否垂直，则决定了是正投影(orthographic)还是斜投影(oblique)。如下图，展示了两种正投影的方法：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled.png" alt="Untitled.png"></p><p>平行投影的特点是：场景中互相平行的两条直线，在投影面中依然平行，因此常被用在工业设计上，但这种方式却与我们的眼睛观察世界的方式不同，眼睛与相机，透过一个特定的视点观察场景，而并不是从单一固定的视线方向接收光线的！这种方式即为透视投影，如下图所示：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled1.png" alt="Untitled1.png"></p><p>所有的视线均会穿过同一个点，即viewport，而非互相平行。有关透视投影的另一个有趣之处在于，原场景中的每组平行线，最后均会相交于同一个点，即vanishing point：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled2.png" alt="Untitled2.png"></p><p>很显然，离视点越远，物体将会越小。</p><h2 id="4-3-Computing-Viewing-Rays"><a href="#4-3-Computing-Viewing-Rays" class="headerlink" title="4.3 Computing Viewing Rays"></a>4.3 Computing Viewing Rays</h2><p>仔细想想，我们有了场景，我们确定了场景如何投影到平面上的方法，现在可以计算每条经过像素的视线了！首先需要确定的是viewport的位置(或是观察方向，对于平行投影而言)，以及投影的平面。</p><p>首先确定光线/视线(至少在本章，它们的意义都差不多)的数学表达形式：</p><p>$$\pmb{p}(t) = \pmb{e} + t(\pmb{s}-\pmb{e})$$</p><p>粗体表示一个三维向量。各向量的意义如下图所示：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled3.png" alt="Untitled3.png"></p><p>参数t确定了光线中的某个点。各个向量则在相机参考系(camera frame)中确定。</p><h3 id="4-3-1-Orthographic-Views"><a href="#4-3-1-Orthographic-Views" class="headerlink" title="4.3.1 Orthographic Views"></a>4.3.1 Orthographic Views</h3><p>在相机参考系w，u，v中考虑问题，所有视线都具有$-\pmb{w}$的方向。</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled4.png" alt="Untitled4.png"></p><p>接下来定义图像平面，用$l&lt;0&lt;r, b&lt;0&lt;t$来定义图像的左右，上下范围。我们假设图像具有的像素数为$n_x \times n_y$，经过简单的数学运算，可以确定在光栅化图像的位置为<code>(i,j)</code>的像素点，其在相机坐标系中的位置为：</p><p>$$u = l+(r-l)(i+0.5)/n_x  \ v = b+(t-b)(j+0.5)/n_y$$</p><p>至此，不需要再进行多余工作，对正交投影而言，生成光线的流程是：</p><ol><li>对<code>(i,j)</code> 计算相应u，v</li><li>确定光线方向为$-\pmb{w}$</li><li>确定光线起点为$\pmb{e} + u\pmb{u} + v\pmb{v}$</li></ol><p>参考图如下：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled5.png" alt="Untitled5.png"></p><p>当然，这里的流程并没有考虑平行投影中斜投影的情况，仅仅是正交投影。</p><h3 id="4-3-2-Perspective-Views"><a href="#4-3-2-Perspective-Views" class="headerlink" title="4.3.2 Perspective Views"></a>4.3.2 Perspective Views</h3><p>来考虑另一种情况：透视投影，即所有光线的发射点为同一个点viewport，而每条光线的方向不同。</p><p>同样参考上图，以下的生成光线的流程是显然的：</p><ol><li>对<code>(i,j)</code> 计算相应u，v</li><li>确定光线方向为$-d\pmb{w}+u\pmb{u}+v\pmb{v}$</li><li>确定光线起点为$\pmb{e}$</li></ol><p>同样地，斜透视投影(即viewport和图像中心连线与图像平面不垂直)中，只需要修改$-d\pmb{w}$为$d\pmb{d}$即可。</p><h2 id="4-4-Ray-Object-Intersection"><a href="#4-4-Ray-Object-Intersection" class="headerlink" title="4.4 Ray-Object Intersection"></a>4.4 Ray-Object Intersection</h2><p>依前所述，无论是平行投影还是透视投影，我们都可以对每一个像素生成相应光线$\pmb{e}+t\pmb{d}$，接下来需要寻找这条光线与场景中最近物体的交点(t&gt;0)。</p><h3 id="4-4-1-Ray-Sphere-Intersection"><a href="#4-4-1-Ray-Sphere-Intersection" class="headerlink" title="4.4.1 Ray-Sphere Intersection"></a>4.4.1 Ray-Sphere Intersection</h3><p>依前，光线有表达式：$\pmb{p}(t)=\pmb{e}+t\pmb{d}$，而物体表面的隐式表达式为：$f(\pmb{p}) = 0$，当下式有t&gt;0的解时，光线与该物体相交：</p><p>$$f(\pmb{p}(t)) = 0$$</p><p>如果把球体上的点定义为p，而圆心为c，球体应有表达式：</p><p>$$(\pmb{p}-\pmb{c})(\pmb{p}-\pmb{c})-R^2=0$$</p><p>将光线p(t)代入上式求解即可：</p><p>$$(\pmb{e}+t\pmb{d}-\pmb{c})(\pmb{e}+t\pmb{d}-\pmb{c})-R^2 = 0$$</p><p>问题转换为求解关于t的一元二次方程，不再赘述。另两个有用的数学式为：</p><ul><li>某点p法向量：$\pmb{n}=2(\pmb{p}-\pmb{c})$</li><li>某点p单位法向量：$(\pmb{p}-\pmb{c})/R$</li></ul><h3 id="4-4-3-Ray-Triangle-Intersection"><a href="#4-4-3-Ray-Triangle-Intersection" class="headerlink" title="4.4.3 Ray-Triangle Intersection"></a>4.4.3 Ray-Triangle Intersection</h3><p>要解决与三角形的相交问题，先来考虑与平面的相交问题。正如直线可以由含一个参数t的表达式表示一样，平面可以由含两个参数u，v的表达式$\pmb{f}(u,v)$表示，故有：</p><p>$$\pmb{e}+t\pmb{d}=\pmb{f}(u,v)\Leftarrow \begin{cases} x_e+tx_d=f(u,v) \ y_e+ty_d=g(u,v) \z_e+tz_d=h(u,v) \end{cases}$$</p><p>此三元方程可解即表示有交点。接下来讨论是否交点在三角形的内部，假设其三个顶点为a，b，c。可以利用如下方程：</p><p>$$\pmb{e}+t\pmb{d} = \pmb{a}+\beta(\pmb{b}-\pmb{a}) + \gamma(\pmb{c}-\pmb{a})$$</p><p>其中，$t,\beta,\gamma$均可解，因为可以按照同样的方式将上式拓展为三元方程，若交点在三角形内，应有解：$\beta&gt;0, \gamma&gt;0, \beta+\gamma&lt;1$。若无解，可能光线平行于平面，或者三个顶点无法形成三角形。利用Cramer’s rule，可以直接求得上式的解。解的表达式见下，太长不想打：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled6.png" alt="Untitled6.png"></p><p>综上，我们可以发展起来一个判断在指定$[t_0,t_1]$范围内的光线与指定三角形是否有交点的算法，胡乱写的伪代码如下，几次判断可以减少运算的次数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">raytri</span><span class="hljs-params">(ray r, vector3 a, vector3 b, vector3 c, interval[t_0,t_1])</span></span>&#123;<br>compute t<br><span class="hljs-keyword">if</span> (t&lt;t_0) || (t&gt;t_1) then<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>compute gamma<br><span class="hljs-keyword">if</span>(gamma&lt;<span class="hljs-number">0</span>) || (gamma&gt;<span class="hljs-number">1</span>) then<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>compute beta<br><span class="hljs-keyword">if</span>(beta&lt;<span class="hljs-number">0</span>) || (beta&gt;<span class="hljs-number">1</span>-gamma) then<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-3-Ray-Polygon-Intersection"><a href="#4-4-3-Ray-Polygon-Intersection" class="headerlink" title="4.4.3 Ray-Polygon Intersection"></a>4.4.3 Ray-Polygon Intersection</h3><p>更进一步，考虑与平面多边形的相交情况。该多边形有p_1至p_m共m个顶点，平面法向量为n，光线则有$\pmb{p}(t) = \pmb{e}+t\pmb{d}$，首先利用下式计算与平面的交点：</p><p>$$(\pmb{p}-\pmb{p}_1)\cdot \pmb{n}=0$$</p><p>可得解为：</p><p>$$t = \frac{(\pmb{p}_1-\pmb{e})\cdot \pmb{n}}{\pmb{d}\cdot \pmb{n}}$$</p><p>接下来即判断由t得到的交点p是否在多边形内。</p><p>基本的想法是从该交点p放出一条射线，计算射线与多边形的交点个数，若个数为奇数，则在内部，否则在外部。通常的简化方法是将多边形与点都映射到一个平面上再进行计算，这样要简便一些。我们此处没有考虑更多特殊情况，如交点恰好为顶点，或是射线在顶点与多边形相交等。</p><p>当然，我们总是可以将多边形分割为多个三角形之后再行判断。</p><h3 id="4-4-4-Intersecting-a-Group-of-Objects"><a href="#4-4-4-Intersecting-a-Group-of-Objects" class="headerlink" title="4.4.4 Intersecting a Group of Objects"></a>4.4.4 Intersecting a Group of Objects</h3><p>在解决了上述问题后，我们可以来谈谈更实际的情景：判断和一组物体的相交，关键之处在于，在给定初始区间[t_0, t_1]中，找到最近的交点，伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">hit = <span class="hljs-literal">false</span><br><span class="hljs-keyword">for</span> each object o in group <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span>(o is hit at ray parameter t <span class="hljs-keyword">and</span> t&gt;t_0 <span class="hljs-keyword">and</span> t&lt;t_1) then<br>hit = <span class="hljs-literal">true</span><br>hitobject = o<br>t_1 = t<br><span class="hljs-keyword">return</span> hit<br></code></pre></td></tr></table></figure><h2 id="4-5-Shading"><a href="#4-5-Shading" class="headerlink" title="4.5 Shading"></a>4.5 Shading</h2><p>当一个像素所对应的物体表面被确定之后，我们需要决定采用的着色(shading)模型来为该像素赋值。本章讨论最简单的两种着色模型。</p><h3 id="4-5-1-Lambertian-Shading"><a href="#4-5-1-Lambertian-Shading" class="headerlink" title="4.5.1 Lambertian Shading"></a>4.5.1 Lambertian Shading</h3><p>最简单的着色模型当属Lambert所设计的模型：光源发射到某一表面的能量取决于光线与该表面的夹角：</p><p>$$L = k_dImax(0, \pmb{n\cdot l})$$</p><p>L为该像素的颜色，k_d则是该表面的漫反射系数，也可以理解为表面颜色，I为光源亮度，两个向量的含义如下图所示：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled7.png" alt="Untitled7.png"></p><p>这里利用点乘获取夹角的余弦值，同时要注意向量需为单位向量。</p><h3 id="4-5-2-Blinn-Phong-Shading"><a href="#4-5-2-Blinn-Phong-Shading" class="headerlink" title="4.5.2 Blinn-Phong Shading"></a>4.5.2 Blinn-Phong Shading</h3><p>Lambertian模型是独立于视角的，即从哪个方向看并不影响看到的颜色，这也是漫反射的特点，没有考虑到镜面反射。</p><p>Blinn-Phong模型是基于这样的想法：当视线$\pmb{v}$与光线$\pmb{l}$相对于表面法向量对称分布时，将会观察到较强的反射光。为了计算两个向量分布的对称程度，引入半程向量h(half vector)，即两向量角平分线上的单位向量，用h与平面法向量的夹角衡量对称程度，夹角越小，则越对称。</p><p>Blinn-Phong模型确定了镜面反射的计算方法，与Lambertian结合起来，有如下形式：</p><p>$$\pmb{h} = \frac{\pmb{v}+\pmb{l}}{|\pmb{v}+\pmb{l}|} \ L=k_dImax(0, \pmb{n\cdot l}) + k_sImax(0,\pmb{n\cdot h})^p$$</p><p>p即Phong指数，用来控制表面的镜面反射程度，当p较大时，镜面反射的光强将在视线远离对称位置后迅速衰减。k_s则为镜面反射系数。</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled8.png" alt="Untitled8.png"></p><h3 id="4-5-3-Ambient-Shading"><a href="#4-5-3-Ambient-Shading" class="headerlink" title="4.5.3 Ambient Shading"></a>4.5.3 Ambient Shading</h3><p>在考虑过镜面反射与漫反射之后，我们的模型仍有一个缺点：那些无法被光源直接照射到的区域将会完全漆黑，而这是非常不合常理的！事实上，因为多次反射的存在，那些没有被直接照射的区域依然能被微弱的环境光照亮，基于此，我们为所有的像素值都加上一个随表面特性而改变的特定值：</p><p>$$L=k_aI_a + k_dImax(0, \pmb{n\cdot l}) + k_sImax(0,\pmb{n\cdot h})^p$$</p><p>k_a代表表面的环境光系数(ambient coefficient)，I_a则表示环境光强度。</p><h3 id="4-5-4-Multiple-Point-Lights"><a href="#4-5-4-Multiple-Point-Lights" class="headerlink" title="4.5.4 Multiple Point Lights"></a>4.5.4 Multiple Point Lights</h3><p>多个光源的情况亦很简单，无非是多个漫反射，镜面反射的强度叠加。而注意，环境光分量并不需要改变：其本身就是复杂的光照叠加的近似结果，假设我们有N个光源：</p><p>$$L=k_aI_a + \sum_{i=1}^N[k_dI_imax(0, \pmb{n\cdot l_i}) + k_sI_imax(0,\pmb{n\cdot h_i})^p]$$</p><h2 id="4-6-A-Ray-Tracing-Program"><a href="#4-6-A-Ray-Tracing-Program" class="headerlink" title="4.6 A Ray-Tracing Program"></a>4.6 A Ray-Tracing Program</h2><p>基于此前的讨论，我们现在应该清楚，光线是如何从特定像素中射出，如何检测光线与物体平面的交点，又如何基于检测结果对像素点进行着色，是时候动手写一个完整的程序了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> each pixel <span class="hljs-keyword">do</span>:<br>compute viewing ray based on projection method<br><span class="hljs-keyword">if</span> ray intersect with object with t&gt;<span class="hljs-number">0</span> then<br>compute normal vector n<br>compute <span class="hljs-keyword">and</span> set pixel value based on shading model<br><span class="hljs-keyword">else</span><br>set pixel value to background color<br></code></pre></td></tr></table></figure><h3 id="4-6-1-Object-Oriented-Design-for-a-Ray-Tracing-Program"><a href="#4-6-1-Object-Oriented-Design-for-a-Ray-Tracing-Program" class="headerlink" title="4.6.1 Object-Oriented Design for a Ray-Tracing Program"></a>4.6.1 Object-Oriented Design for a Ray-Tracing Program</h3><p>这里不太好懂。。只是讲编程的思想而非实践。</p><p>总的来说，所有能被光线检测到碰撞的物体都应被定义为surface或其子类，这一基类/抽象类的行为如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">surface</span></span><br><span class="hljs-class"><span class="hljs-title">virtual</span> <span class="hljs-title">bool</span> <span class="hljs-title">hit</span>(<span class="hljs-title">ray</span> <span class="hljs-title">e</span>+<span class="hljs-title">td</span>, <span class="hljs-title">real</span> <span class="hljs-title">t_0</span>, <span class="hljs-title">real</span> <span class="hljs-title">t_1</span>, <span class="hljs-title">hit</span>-<span class="hljs-title">record</span> <span class="hljs-title">rec</span>)</span><br><span class="hljs-class"><span class="hljs-title">virtual</span> <span class="hljs-title">box</span> <span class="hljs-title">bounding</span>-<span class="hljs-title">box</span>()</span><br></code></pre></td></tr></table></figure><p>rec是一个用于返回的引用参数，返回如相交时的t值等。</p><h2 id="4-7-Shadows"><a href="#4-7-Shadows" class="headerlink" title="4.7 Shadows"></a>4.7 Shadows</h2><p>在如前所述的框架下，要考虑阴影是简单的。当检测到碰撞后，我们可以从返回的信息中得到光线向量$\pmb{l}$，此时的碰撞点亦已知，那么，只要我们从该碰撞点向光源方向“望去”，或者说发出一条射线并在遇到光源前检测到与其他物体的碰撞，说明此处为阴影，否则可以被照射。</p><p>不同于viewing ray，此处放出的射线，我们定义为shadow ray。如下图所示，还有一个要注意的问题是，我们的shadow ray可能因为数值计算的精度关系，检测到与p点所在的平面的相交情况！为了避免这种错误，我们常常设置一个极小值$\varepsilon$：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled9.png" alt="Untitled9.png"></p><p>于是，借助此前的hit函数，我们可以定义完整的返回pixel color的函数，详见p86：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">function <span class="hljs-title">raycolor</span><span class="hljs-params">(ray e+td, real t_0, real t_1)</span></span><br>hit-record rec, srec<br><span class="hljs-comment">//检测到与某物体表面相交</span><br><span class="hljs-keyword">if</span>(scene-&gt;<span class="hljs-built_in">hit</span>(ray, t_0, t_1, rec)) then<br><span class="hljs-comment">//计算相交位置</span><br>p = e + rec.t*d<br><span class="hljs-comment">//计算环境光分量</span><br>color c = rec.k_a*I_a<br><span class="hljs-comment">//检测碰撞</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> scene-&gt;<span class="hljs-built_in">hit</span>(p+sl, epsilon, infinite, srec)) then<br>calculate vector3 h = <span class="hljs-built_in">normalized</span>(l + (-d))<br>c = c + rec.k_d*I*<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, rec.n*l) + rec.k_s*I*<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, rec.n*h)^(rec.p)<br><span class="hljs-keyword">return</span> c<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> background-color<br></code></pre></td></tr></table></figure><h2 id="4-8-Ideal-Specular-Reflection"><a href="#4-8-Ideal-Specular-Reflection" class="headerlink" title="4.8 Ideal Specular Reflection"></a>4.8 Ideal Specular Reflection</h2><p>为了更为真实的镜面反射效果，我们可以模拟一面镜子的效果，这需要我们在与镜子的交点处再发出一条对称的视线，如下图所示：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled10.png" alt="Untitled10.png"></p><p>向量r可由下式得到：</p><p>$$\pmb{r} = \pmb{d} - 2(\pmb{d\cdot n})\pmb{n}$$</p><p>借助于此前所函数raycolor，我们需要清楚这一函数完成了什么工作：在指定的相机参考系中，放出一条光线，并返回应该得到的着色值，我们只需要将这条放出的光线替换为r即可，最终的着色值为<code>color c = c + k_m*raycolor(p+sr, epsilon, infinite)</code> ，其中的k_m代表着反射镜面的系数，p为镜面上的相交点，取区间为$[\varepsilon, \infty)$的意义与shadow ray一致：防止检测到与镜面本身的碰撞。</p><p>当然，为了防止这一递归式无尽地计算(这一情况还是比较常见的，就比如把两块镜子摆在一起)。通常的解决方案是设定一个最大的递归深度(但是到递归深度以后的默认值该如何选取？不懂)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fundamental of CG研习：Chapter3 Raster Images</title>
    <link href="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter3%20Raster%20Images/"/>
    <url>/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter3%20Raster%20Images/</url>
    
    <content type="html"><![CDATA[<h1 id="3-Raster-Images"><a href="#3-Raster-Images" class="headerlink" title="3 Raster Images"></a>3 Raster Images</h1><p>章名为光栅图像。</p><p>为了在显示屏上显示图像，计算机需要将图像处理为以像素点表示的数据，即光栅化。每个像素可以发出红绿蓝光以合成为任意颜色。</p><p>而电脑处理的图像通常分为两类，raster image与vector image。在理想的情况下，raster image中的每一个像素点可以对应显示屏上的每一个像素点，但在大多数情况下，无法做到这种一一对应的关系。vector image的好处则在于支持任意尺度的缩放而不受到影响，这种图像以线段，曲线，形状进行描述，存在的问题是，要将这种较为抽象的图像显示出来，需要先经过光栅化的过程，这也是本章的主要论题。</p><h2 id="3-1-Raster-Device"><a href="#3-1-Raster-Device" class="headerlink" title="3.1 Raster Device"></a>3.1 Raster Device</h2><p>在讨论光栅化图像之前，先来看看如何显示图像的设备。通常的显示设备可以分为LCD(liquid crystal display，液晶显示)与LED(light-emitting diode，发光二极管)，二者的详细区别在下节叙述：</p><h3 id="3-1-1"><a href="#3-1-1" class="headerlink" title="3.1.1"></a>3.1.1</h3><p>当今的显示器大多基于固定尺寸的像素阵列，如电视与数码放映机。而这些显示器又大多分为两类：</p><ul><li><p>emissive displays</p><p>  使用像素本身发射光线(LED)。</p></li><li><p>transmissive displays</p><p>  像素本身并不发光，而是控制通过其的光线能量(LCD)。</p></li></ul><p>LCD的原理比较有意思，而LED的原理较为容易理解。对LED来说，一个像素的光线由三个子像素发射，而三个子像素的尺寸很小，肉眼不可见，通过通过二极管的电流大小，可以控制每种颜色光的强度，经过混合就得到了多种颜色。而LCD的是通过液晶的特性，通过电压改变液晶朝向，再改变通过光的偏振方向，从而改变通过光的强度，做到对每种原色光的强度控制：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter3%20Raster%20Images/Untitled.png" alt="Untitled.png"></p><h3 id="3-1-2-Hardcopy-Devices"><a href="#3-1-2-Hardcopy-Devices" class="headerlink" title="3.1.2 Hardcopy Devices"></a>3.1.2 Hardcopy Devices</h3><p>这章并没有仔细看，随便讲讲，没什么意思。讲的是印刷设备的原理。对印刷设备而言，ppi可以表示像素的密度，而dpi(dots per inch)则表示一个黑白打印机，即像素点非黑即白的点密度。</p><h3 id="3-1-3-Input-Devices"><a href="#3-1-3-Input-Devices" class="headerlink" title="3.1.3 Input Devices"></a>3.1.3 Input Devices</h3><p>图像的输入设备当属相机。</p><h2 id="3-2-Images-Pixels-and-Geometry"><a href="#3-2-Images-Pixels-and-Geometry" class="headerlink" title="3.2 Images, Pixels, and Geometry"></a>3.2 Images, Pixels, and Geometry</h2><p>我们可以将一个待显示的图像抽象为函数：</p><p>$$I(x,y): R \rightarrow V$$</p><p>V表示像素的可能值集合，而R是图像的显示范围。对于彩色图像而言，V是一个三维向量，分别代表红，绿，蓝强度。</p><p>像素的坐标与屏幕的对应关系通常由下图表示：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter3%20Raster%20Images/Untitled1.png" alt="Untitled1.png"></p><p>若一幅图像的尺寸为$(n_x, n_y)$，这里的尺寸意义为像素点个数，那么该图像的显示范围可以表示为下式：</p><p>$$R = [-0.5, n_x-0.5]\times[-0.5, n_y-0.5]$$</p><h3 id="3-2-1-Pixel-Values"><a href="#3-2-1-Pixel-Values" class="headerlink" title="3.2.1 Pixel Values"></a>3.2.1 Pixel Values</h3><p>本章讨论像素值的储存方式。假设每个像素的值都由三个32位浮点数表示，那么图像的尺寸将非常巨大，我们需要减少这一数值。首先，由于设备的限制，我们当然不可能将像素的光强设为无限大，通常，我们取其值域为[0,1]。对于一个8bit图像，通常的做法是储存为0, 1/255…, 254/255, 1。</p><p>以浮点数的方式储存的图像通常称为high dynamic range images(HDR)，这种图像的值域较宽，与之相对的是以整数形式存储的图像，称为LDR images。无论何种图像，都希望可以做到减少存储所需要的内存空间。</p><p>以有限值域的方式存储图像所导致的第一个问题是clipping，即剪切。当需要的光强太高，例如拍摄太阳时，所有亮度大于我们所设定的最大像素亮度值的输入值都会被设为最大值，这造成了细节上的损失。同时，以有限精度编码图像会导致quantization artifacts，即图像中出现明显的分层现象，这是因为图像的编码方式或许精度过低，无法反映亮度的细微渐变变化。</p><h3 id="3-2-2-Monitor-Intensities-and-Gamma"><a href="#3-2-2-Monitor-Intensities-and-Gamma" class="headerlink" title="3.2.2 Monitor Intensities and Gamma"></a>3.2.2 Monitor Intensities and Gamma</h3><p>本章主要讨论图像的输入值如何经过处理后被显示在具体设备上的过程。</p><p>首先明确一点，我们需要达到的目的是什么？假设图像的输入范围为0到1，输入为0时，我们希望设备完全不发光，而输入为1时，我们希望设备的三个通道均以最大亮度显示，以显示最亮的白色，更远一些，当输入值为0.5时呢？理所当然地，我们希望此时设备所发射的光线能量为值为1时的恰好一半。</p><p>当然，此处我们暂且不论人眼对光的感知能力与光的能量并不成线性关系，因为这会使我们的讨论变得复杂而没有暂时必要。</p><p>问题在于，我们的设备输出能量与其接受的输入值对应关系时非线性的！以0.5输入为例，我们的输出能量可能仅有0.25，输入值与输出能量之间的关系可以用下式模拟：</p><p>$$displayed\ intensity = (maximum\ intensity)a^\gamma$$</p><p>a即输入值，当a为0/1时，显示能量依然是与输入值对应的，对其他输入值则并非如此。为了了解输入与输出能量的关系，我们需要求出公式中的$\gamma$，在这里，有一种巧妙的方式解决这一问题：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter3%20Raster%20Images/Untitled2.png" alt="Untitled2.png"></p><p>公式中$\gamma$的求解需要其余三个量已知！我们需要找到当设备的输出能量恰好等于最大能量的一半时，输入值a到底是多少。如果能够得知此时的a值，那么可以解得：</p><p>$$\gamma = \frac{ln 0.5}{ln a}$$</p><p>可是如何调节设备使其输出的能量恰好为最大能量的一半呢？看到上图应该就会有答案。在左边，我们以棋盘的方式放置黑白像素，以使其比例为1：1，当像素点够密时，其呈现的外观与一副均匀的灰色图像无异，此时，我们需要用户手动调节右边图像的输入值，以使两边图像的亮度一致，此时，我们可以认为右边图像的输入值恰好使设备的输出为最大能量的一半！</p><p>这就是游戏中常常遇到的gamma亮度调节，这一方法用于求出设备的这一属性，被运用得相当广泛。通过求得$\gamma$值，我们对于这台设备的输入输出特性已然掌握，通过调节输入值，我们就可以使输出的能量与我们想要的效果达到一致！而非产生公式所描述的偏差：</p><p>$$a’ = a^{\frac{1}{\gamma}}$$</p><p>每当我们要输入a值给设备时，我们将其替换为a’，通过这种方式，得到设备的输出能量：</p><p>$$displayed\ intensity = (maximum\ intensity)(a^{\frac{1}{\gamma}})^\gamma = a(maximum\ intensity)$$</p><p>这就是我们想要的效果！</p><h2 id="3-3-RGB-Color"><a href="#3-3-RGB-Color" class="headerlink" title="3.3 RGB Color"></a>3.3 RGB Color</h2><p>以RGB表示的光混合方法是一种additive manner，这种混合方法是建立在我们的显示设备是依靠自发光而非反射光来进行显示的基础之上的。与之相对的混合方法为subtractive manner，其三原色为红黄蓝，印刷制品本身并不发光，故其为减法。</p><p>在以RGB方式表示色彩时，通常采用的方法是使用一个字节即0-255表示一个分量值，同样地，每个分量都会遇到伽马校正，即上界所介绍的问题，而每个分量都可以以相同的方法进行校正。</p><h2 id="3-4-Alpha-Compositing"><a href="#3-4-Alpha-Compositing" class="headerlink" title="3.4 Alpha Compositing"></a>3.4 Alpha Compositing</h2><p>本节考虑如何处理半透明物体如玻璃等,同样地, 当前景与后景分别占到一个像素的一部分时, 也需要考虑两部分混合的问题.</p><p>自然地, 我们考虑颜色为$c_f$的前景物体所占单个像素比例为$\alpha$时, 有该像素颜色为:</p><p>$$c = \alpha c_f + (1-\alpha)c_b$$</p><p>而对于一些半透明的图像, 我们需要利用alpha通道去存储这一像素的透明度, alpha通道和RGB三通道共同描述了一个RGBA图像:</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter3%20Raster%20Images/Untitled3.png" alt="Untitled3.png"></p><h3 id="3-4-1-Image-Storage"><a href="#3-4-1-Image-Storage" class="headerlink" title="3.4.1 Image Storage"></a>3.4.1 Image Storage</h3><p>要完全地存储某一图像的全部信息, 例如说, RGB图像的每个通道都使用8bit去描述, 根据图像的像素数量我们当然可以轻松计算这一图像的大小, 往往比较大, 这就需要进行压缩, 分lossless即无损与lossy有损两种方式. 常见的jpeg格式为有损的, 而tiff, ppm, png则是无损的格式.</p><h2 id="一个有趣的问题"><a href="#一个有趣的问题" class="headerlink" title="一个有趣的问题"></a>一个有趣的问题</h2><p>为什么我们不在制造显示器时即调试好设备, 使其在接收到输入时线性地输出能量, 而是需要用户进行手动调节?</p><p>看不懂书上的解释, mark先啦.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
