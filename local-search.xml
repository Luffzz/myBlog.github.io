<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Fundamental of CG研习：Chapter1 Introduction</title>
    <link href="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter1%20Introduction/"/>
    <url>/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter1%20Introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><h2 id="1-1-Graphics-Area"><a href="#1-1-Graphics-Area" class="headerlink" title="1.1 Graphics Area"></a>1.1 Graphics Area</h2><p>图形学领域的研究问题大体上可以分为三块：</p><ol><li>Modeling，处理在计算机中存储，表示物体的方法，包括其形状，外观特性等。如物体的点坐标，反射模型。</li><li>Rendering，利用model提供的信息将场景渲染为图像</li><li>Animation，关注使用前两者呈现动态效果的问题。</li></ol><h2 id="1-3-Graphics-APIs"><a href="#1-3-Graphics-APIs" class="headerlink" title="1.3 Graphics APIs"></a>1.3 Graphics APIs</h2><p>图形API负责绘制图像并映射至屏幕中。有两大类：Java，Direct3D与OpenGL。</p><h2 id="1-4-Graphics-Pipeline"><a href="#1-4-Graphics-Pipeline" class="headerlink" title="1.4 Graphics Pipeline"></a>1.4 Graphics Pipeline</h2><p>图形流水线被用于绘制透视图中的3D原语。</p><p>场景中的三角形数量很大程度上影响了图像的生成速度，我们可以使用level of detail，即LOD决定该以何种等级展示model的细节，从而控制三角形面片的数量。</p><h2 id="1-5-Numerical-Issues"><a href="#1-5-Numerical-Issues" class="headerlink" title="1.5 Numerical Issues"></a>1.5 Numerical Issues</h2><p>图形渲染的计算过程中，一些数值问题不可忽视，以浮点数为例，通行的标准IEEE-floating-point提供了一下几个特殊值：为程序提供了方便：</p><p>$$\infty ,-\infty ,NaN$$</p><p>这些特殊值在处理除零错误，避免程序因一些特殊情况而崩溃时十分有用，详见p6-7</p><h2 id="1-6-Efficiency"><a href="#1-6-Efficiency" class="headerlink" title="1.6 Efficiency"></a>1.6 Efficiency</h2><p>为了提高代码的效率，一些准则值得被采纳。例如，相较于处理器计算能力的增长，内存的访问速度增速缓慢，这意味着我们更应该关注减少内存访问，而非指令的执行次数，可以改善性能的方法包括：</p><ul><li>避免存储计算中间结果，而直接书写为一行代码，尽管这意味着可读性的下降</li><li>在优化模式下编译</li><li>尝试使用分析工具找到代码瓶颈，即决定运行速度的关键部分</li><li>以可能的方式修改数据结构使之契合设备的缓存，页的尺寸</li><li>检查生成的汇编文件以寻找改善空间</li></ul><p>还需要注意的是，有时不必遵循一些古老的建议，例如，当今的CPU可以以相同的速度处理浮点数和整型数，而不必刻意避免浮点数的使用。</p><h2 id="1-7-Designing-and-Coding-Graphics-Programs"><a href="#1-7-Designing-and-Coding-Graphics-Programs" class="headerlink" title="1.7 Designing and Coding Graphics Programs"></a>1.7 Designing and Coding Graphics Programs</h2><p>良好的图形程序需要有良好的类与例程以表示集合实体，例如向量，矩阵，RGB值等。</p><p>为了减少内存的使用，我们当然希望使用空间小的float而非double。但为了避免可能的数值问题，我们又需要使用double而非float，tradeoffs depend on the program。一个建议是全部使用float，直到出现问题时，才将必要的部分变为double。</p><p>以下的几个针对图形程序的调试建议是有用的：</p><ul><li><p>The Scientific Method</p><p>  关闭，启用一些可能存在问题的元素如光照，阴影，有时候就能找到问题</p></li><li><p>Images as Coded Debugging Output</p><p>  以图像的方式显示一些关键信息，例如，把每个顶点的法向量值作为一张图像的输入，这样显然可以非常直观的发现这些被映射为图像的数据可能存在的问题</p></li><li><p>Using a Debugger</p><p>  图形渲染常常意味着同一指令的重复执行，借由崩溃信息，我们或许可以知道是哪一行有问题，但却很难发现是哪一次执行出现了问题，修改代码以使其在怀疑的地方触发break point十分有用。同时，我印象中Visual Studio也提供了条件端点这一功能，这避免了我们对代码的修改。如下，我们怀疑在(126,247)这一处出了问题：</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic">if x==126 and y==247 then:<br>print &quot;blarg!&quot;<br></code></pre></td></tr></table></figure></li><li><p>Data Visualization for Debugging</p><p>  尝试去可视化程序的中间状态，或许可以发现问题</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fundamental of CG研习：Chapter2 Miscellaneous Math</title>
    <link href="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter2%20Miscellaneous%20Math/"/>
    <url>/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter2%20Miscellaneous%20Math/</url>
    
    <content type="html"><![CDATA[<h1 id="2-Miscellaneous-Math"><a href="#2-Miscellaneous-Math" class="headerlink" title="2 Miscellaneous Math"></a>2 Miscellaneous Math</h1><p>这一章的主要内容在于介绍各种图形学中使用到的数学知识，大部分都已经学过，在要使用到时再行补充。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fundamental of CG研习：Chapter4 Ray Tracing</title>
    <link href="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/"/>
    <url>/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/</url>
    
    <content type="html"><![CDATA[<h1 id="4-Ray-Tracing"><a href="#4-Ray-Tracing" class="headerlink" title="4 Ray Tracing"></a>4 Ray Tracing</h1><p>本章讨论光线追踪技术. </p><p>基本上, 渲染是一个将一系列物体, 场景的布置作为输入, 并输出相应的像素阵列的过程.而渲染亦可分为两类: object-order rendering与image-order rendering. </p><ul><li>object-order rendering按顺序考虑要渲染的每个物体, 每当考虑一个物体时, 更新与这一物体有关联的所有像素点.</li><li>image-order rendering则按顺序考虑每个像素点并计算这一像素的最终值, 因此在计算时, 需要考虑所有可能影响这一像素值的物体.</li></ul><p>宽泛地讲, image-order rendering的工作原理会更简单, 能够达到的效果会更具有弹性, 但通常也需要更多的执行时间去产生一张图像. Ray tracing就是一种image order算法.</p><h2 id="4-1-The-Basic-Ray-Tracing-Algorithm"><a href="#4-1-The-Basic-Ray-Tracing-Algorithm" class="headerlink" title="4.1 The Basic Ray-Tracing Algorithm"></a>4.1 The Basic Ray-Tracing Algorithm</h2><p>Ray tracer每次计算一个像素, 而每个像素的任务是找到从这个像素出发, 所能”看到”的物体, 在确定了这一物体后, 根据合适的着色模型决定这一像素的最终值, 基于这样的原理, 可以将ray tracer的工作流程分为三步:</p><ol><li>ray generation: 计算通过每个像素的视线(viewing ray), 其出发点与方向.</li><li>ray intersection: 对每条实现, 找到与该视线相交的最近物体</li><li>shading: 基于相交检测的结果, 决定最终该像素的颜色</li></ol><h2 id="4-2-Perspective"><a href="#4-2-Perspective" class="headerlink" title="4.2 Perspective"></a>4.2 Perspective</h2><p>我们首先需要思考将3D场景转换为2D图像的方式, 大多数摄影, 美术所遵循的原则是: linear perspective，简单来说，在场景中的直线，在投影到2D平面时，需要依然为直线。</p><p>最简单的投影方式是平行投影，从图中很容易看出这种方式的特点：将物体延一定方向运动直至接触到投影平面，以此决定看到的景象，而投影的方向与平面是否垂直，则决定了是正投影(orthographic)还是斜投影(oblique)。如下图，展示了两种正投影的方法：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled.png" alt="Untitled.png"></p><p>平行投影的特点是：场景中互相平行的两条直线，在投影面中依然平行，因此常被用在工业设计上，但这种方式却与我们的眼睛观察世界的方式不同，眼睛与相机，透过一个特定的视点观察场景，而并不是从单一固定的视线方向接收光线的！这种方式即为透视投影，如下图所示：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled1.png" alt="Untitled1.png"></p><p>所有的视线均会穿过同一个点，即viewport，而非互相平行。有关透视投影的另一个有趣之处在于，原场景中的每组平行线，最后均会相交于同一个点，即vanishing point：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled2.png" alt="Untitled2.png"></p><p>很显然，离视点越远，物体将会越小。</p><h2 id="4-3-Computing-Viewing-Rays"><a href="#4-3-Computing-Viewing-Rays" class="headerlink" title="4.3 Computing Viewing Rays"></a>4.3 Computing Viewing Rays</h2><p>仔细想想，我们有了场景，我们确定了场景如何投影到平面上的方法，现在可以计算每条经过像素的视线了！首先需要确定的是viewport的位置(或是观察方向，对于平行投影而言)，以及投影的平面。</p><p>首先确定光线/视线(至少在本章，它们的意义都差不多)的数学表达形式：</p><p>$$\pmb{p}(t) = \pmb{e} + t(\pmb{s}-\pmb{e})$$</p><p>粗体表示一个三维向量。各向量的意义如下图所示：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled3.png" alt="Untitled3.png"></p><p>参数t确定了光线中的某个点。各个向量则在相机参考系(camera frame)中确定。</p><h3 id="4-3-1-Orthographic-Views"><a href="#4-3-1-Orthographic-Views" class="headerlink" title="4.3.1 Orthographic Views"></a>4.3.1 Orthographic Views</h3><p>在相机参考系w，u，v中考虑问题，所有视线都具有$-\pmb{w}$的方向。</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled4.png" alt="Untitled4.png"></p><p>接下来定义图像平面，用$l&lt;0&lt;r, b&lt;0&lt;t$来定义图像的左右，上下范围。我们假设图像具有的像素数为$n_x \times n_y$，经过简单的数学运算，可以确定在光栅化图像的位置为<code>(i,j)</code>的像素点，其在相机坐标系中的位置为：</p><p>$$u = l+(r-l)(i+0.5)/n_x  \ v = b+(t-b)(j+0.5)/n_y$$</p><p>至此，不需要再进行多余工作，对正交投影而言，生成光线的流程是：</p><ol><li>对<code>(i,j)</code> 计算相应u，v</li><li>确定光线方向为$-\pmb{w}$</li><li>确定光线起点为$\pmb{e} + u\pmb{u} + v\pmb{v}$</li></ol><p>参考图如下：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled5.png" alt="Untitled5.png"></p><p>当然，这里的流程并没有考虑平行投影中斜投影的情况，仅仅是正交投影。</p><h3 id="4-3-2-Perspective-Views"><a href="#4-3-2-Perspective-Views" class="headerlink" title="4.3.2 Perspective Views"></a>4.3.2 Perspective Views</h3><p>来考虑另一种情况：透视投影，即所有光线的发射点为同一个点viewport，而每条光线的方向不同。</p><p>同样参考上图，以下的生成光线的流程是显然的：</p><ol><li>对<code>(i,j)</code> 计算相应u，v</li><li>确定光线方向为$-d\pmb{w}+u\pmb{u}+v\pmb{v}$</li><li>确定光线起点为$\pmb{e}$</li></ol><p>同样地，斜透视投影(即viewport和图像中心连线与图像平面不垂直)中，只需要修改$-d\pmb{w}$为$d\pmb{d}$即可。</p><h2 id="4-4-Ray-Object-Intersection"><a href="#4-4-Ray-Object-Intersection" class="headerlink" title="4.4 Ray-Object Intersection"></a>4.4 Ray-Object Intersection</h2><p>依前所述，无论是平行投影还是透视投影，我们都可以对每一个像素生成相应光线$\pmb{e}+t\pmb{d}$，接下来需要寻找这条光线与场景中最近物体的交点(t&gt;0)。</p><h3 id="4-4-1-Ray-Sphere-Intersection"><a href="#4-4-1-Ray-Sphere-Intersection" class="headerlink" title="4.4.1 Ray-Sphere Intersection"></a>4.4.1 Ray-Sphere Intersection</h3><p>依前，光线有表达式：$\pmb{p}(t)=\pmb{e}+t\pmb{d}$，而物体表面的隐式表达式为：$f(\pmb{p}) = 0$，当下式有t&gt;0的解时，光线与该物体相交：</p><p>$$f(\pmb{p}(t)) = 0$$</p><p>如果把球体上的点定义为p，而圆心为c，球体应有表达式：</p><p>$$(\pmb{p}-\pmb{c})(\pmb{p}-\pmb{c})-R^2=0$$</p><p>将光线p(t)代入上式求解即可：</p><p>$$(\pmb{e}+t\pmb{d}-\pmb{c})(\pmb{e}+t\pmb{d}-\pmb{c})-R^2 = 0$$</p><p>问题转换为求解关于t的一元二次方程，不再赘述。另两个有用的数学式为：</p><ul><li>某点p法向量：$\pmb{n}=2(\pmb{p}-\pmb{c})$</li><li>某点p单位法向量：$(\pmb{p}-\pmb{c})/R$</li></ul><h3 id="4-4-3-Ray-Triangle-Intersection"><a href="#4-4-3-Ray-Triangle-Intersection" class="headerlink" title="4.4.3 Ray-Triangle Intersection"></a>4.4.3 Ray-Triangle Intersection</h3><p>要解决与三角形的相交问题，先来考虑与平面的相交问题。正如直线可以由含一个参数t的表达式表示一样，平面可以由含两个参数u，v的表达式$\pmb{f}(u,v)$表示，故有：</p><p>$$\pmb{e}+t\pmb{d}=\pmb{f}(u,v)\Leftarrow \begin{cases} x_e+tx_d=f(u,v) \ y_e+ty_d=g(u,v) \z_e+tz_d=h(u,v) \end{cases}$$</p><p>此三元方程可解即表示有交点。接下来讨论是否交点在三角形的内部，假设其三个顶点为a，b，c。可以利用如下方程：</p><p>$$\pmb{e}+t\pmb{d} = \pmb{a}+\beta(\pmb{b}-\pmb{a}) + \gamma(\pmb{c}-\pmb{a})$$</p><p>其中，$t,\beta,\gamma$均可解，因为可以按照同样的方式将上式拓展为三元方程，若交点在三角形内，应有解：$\beta&gt;0, \gamma&gt;0, \beta+\gamma&lt;1$。若无解，可能光线平行于平面，或者三个顶点无法形成三角形。利用Cramer’s rule，可以直接求得上式的解。解的表达式见下，太长不想打：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled6.png" alt="Untitled6.png"></p><p>综上，我们可以发展起来一个判断在指定$[t_0,t_1]$范围内的光线与指定三角形是否有交点的算法，胡乱写的伪代码如下，几次判断可以减少运算的次数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">raytri</span><span class="hljs-params">(ray r, vector3 a, vector3 b, vector3 c, interval[t_0,t_1])</span></span>&#123;<br>compute t<br><span class="hljs-keyword">if</span> (t&lt;t_0) || (t&gt;t_1) then<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>compute gamma<br><span class="hljs-keyword">if</span>(gamma&lt;<span class="hljs-number">0</span>) || (gamma&gt;<span class="hljs-number">1</span>) then<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>compute beta<br><span class="hljs-keyword">if</span>(beta&lt;<span class="hljs-number">0</span>) || (beta&gt;<span class="hljs-number">1</span>-gamma) then<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-3-Ray-Polygon-Intersection"><a href="#4-4-3-Ray-Polygon-Intersection" class="headerlink" title="4.4.3 Ray-Polygon Intersection"></a>4.4.3 Ray-Polygon Intersection</h3><p>更进一步，考虑与平面多边形的相交情况。该多边形有p_1至p_m共m个顶点，平面法向量为n，光线则有$\pmb{p}(t) = \pmb{e}+t\pmb{d}$，首先利用下式计算与平面的交点：</p><p>$$(\pmb{p}-\pmb{p}_1)\cdot \pmb{n}=0$$</p><p>可得解为：</p><p>$$t = \frac{(\pmb{p}_1-\pmb{e})\cdot \pmb{n}}{\pmb{d}\cdot \pmb{n}}$$</p><p>接下来即判断由t得到的交点p是否在多边形内。</p><p>基本的想法是从该交点p放出一条射线，计算射线与多边形的交点个数，若个数为奇数，则在内部，否则在外部。通常的简化方法是将多边形与点都映射到一个平面上再进行计算，这样要简便一些。我们此处没有考虑更多特殊情况，如交点恰好为顶点，或是射线在顶点与多边形相交等。</p><p>当然，我们总是可以将多边形分割为多个三角形之后再行判断。</p><h3 id="4-4-4-Intersecting-a-Group-of-Objects"><a href="#4-4-4-Intersecting-a-Group-of-Objects" class="headerlink" title="4.4.4 Intersecting a Group of Objects"></a>4.4.4 Intersecting a Group of Objects</h3><p>在解决了上述问题后，我们可以来谈谈更实际的情景：判断和一组物体的相交，关键之处在于，在给定初始区间[t_0, t_1]中，找到最近的交点，伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">hit = <span class="hljs-literal">false</span><br><span class="hljs-keyword">for</span> each object o in group <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span>(o is hit at ray parameter t <span class="hljs-keyword">and</span> t&gt;t_0 <span class="hljs-keyword">and</span> t&lt;t_1) then<br>hit = <span class="hljs-literal">true</span><br>hitobject = o<br>t_1 = t<br><span class="hljs-keyword">return</span> hit<br></code></pre></td></tr></table></figure><h2 id="4-5-Shading"><a href="#4-5-Shading" class="headerlink" title="4.5 Shading"></a>4.5 Shading</h2><p>当一个像素所对应的物体表面被确定之后，我们需要决定采用的着色(shading)模型来为该像素赋值。本章讨论最简单的两种着色模型。</p><h3 id="4-5-1-Lambertian-Shading"><a href="#4-5-1-Lambertian-Shading" class="headerlink" title="4.5.1 Lambertian Shading"></a>4.5.1 Lambertian Shading</h3><p>最简单的着色模型当属Lambert所设计的模型：光源发射到某一表面的能量取决于光线与该表面的夹角：</p><p>$$L = k_dImax(0, \pmb{n\cdot l})$$</p><p>L为该像素的颜色，k_d则是该表面的漫反射系数，也可以理解为表面颜色，I为光源亮度，两个向量的含义如下图所示：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled7.png" alt="Untitled7.png"></p><p>这里利用点乘获取夹角的余弦值，同时要注意向量需为单位向量。</p><h3 id="4-5-2-Blinn-Phong-Shading"><a href="#4-5-2-Blinn-Phong-Shading" class="headerlink" title="4.5.2 Blinn-Phong Shading"></a>4.5.2 Blinn-Phong Shading</h3><p>Lambertian模型是独立于视角的，即从哪个方向看并不影响看到的颜色，这也是漫反射的特点，没有考虑到镜面反射。</p><p>Blinn-Phong模型是基于这样的想法：当视线$\pmb{v}$与光线$\pmb{l}$相对于表面法向量对称分布时，将会观察到较强的反射光。为了计算两个向量分布的对称程度，引入半程向量h(half vector)，即两向量角平分线上的单位向量，用h与平面法向量的夹角衡量对称程度，夹角越小，则越对称。</p><p>Blinn-Phong模型确定了镜面反射的计算方法，与Lambertian结合起来，有如下形式：</p><p>$$\pmb{h} = \frac{\pmb{v}+\pmb{l}}{|\pmb{v}+\pmb{l}|} \ L=k_dImax(0, \pmb{n\cdot l}) + k_sImax(0,\pmb{n\cdot h})^p$$</p><p>p即Phong指数，用来控制表面的镜面反射程度，当p较大时，镜面反射的光强将在视线远离对称位置后迅速衰减。k_s则为镜面反射系数。</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled8.png" alt="Untitled8.png"></p><h3 id="4-5-3-Ambient-Shading"><a href="#4-5-3-Ambient-Shading" class="headerlink" title="4.5.3 Ambient Shading"></a>4.5.3 Ambient Shading</h3><p>在考虑过镜面反射与漫反射之后，我们的模型仍有一个缺点：那些无法被光源直接照射到的区域将会完全漆黑，而这是非常不合常理的！事实上，因为多次反射的存在，那些没有被直接照射的区域依然能被微弱的环境光照亮，基于此，我们为所有的像素值都加上一个随表面特性而改变的特定值：</p><p>$$L=k_aI_a + k_dImax(0, \pmb{n\cdot l}) + k_sImax(0,\pmb{n\cdot h})^p$$</p><p>k_a代表表面的环境光系数(ambient coefficient)，I_a则表示环境光强度。</p><h3 id="4-5-4-Multiple-Point-Lights"><a href="#4-5-4-Multiple-Point-Lights" class="headerlink" title="4.5.4 Multiple Point Lights"></a>4.5.4 Multiple Point Lights</h3><p>多个光源的情况亦很简单，无非是多个漫反射，镜面反射的强度叠加。而注意，环境光分量并不需要改变：其本身就是复杂的光照叠加的近似结果，假设我们有N个光源：</p><p>$$L=k_aI_a + \sum_{i=1}^N[k_dI_imax(0, \pmb{n\cdot l_i}) + k_sI_imax(0,\pmb{n\cdot h_i})^p]$$</p><h2 id="4-6-A-Ray-Tracing-Program"><a href="#4-6-A-Ray-Tracing-Program" class="headerlink" title="4.6 A Ray-Tracing Program"></a>4.6 A Ray-Tracing Program</h2><p>基于此前的讨论，我们现在应该清楚，光线是如何从特定像素中射出，如何检测光线与物体平面的交点，又如何基于检测结果对像素点进行着色，是时候动手写一个完整的程序了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> each pixel <span class="hljs-keyword">do</span>:<br>compute viewing ray based on projection method<br><span class="hljs-keyword">if</span> ray intersect with object with t&gt;<span class="hljs-number">0</span> then<br>compute normal vector n<br>compute <span class="hljs-keyword">and</span> set pixel value based on shading model<br><span class="hljs-keyword">else</span><br>set pixel value to background color<br></code></pre></td></tr></table></figure><h3 id="4-6-1-Object-Oriented-Design-for-a-Ray-Tracing-Program"><a href="#4-6-1-Object-Oriented-Design-for-a-Ray-Tracing-Program" class="headerlink" title="4.6.1 Object-Oriented Design for a Ray-Tracing Program"></a>4.6.1 Object-Oriented Design for a Ray-Tracing Program</h3><p>这里不太好懂。。只是讲编程的思想而非实践。</p><p>总的来说，所有能被光线检测到碰撞的物体都应被定义为surface或其子类，这一基类/抽象类的行为如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">surface</span></span><br><span class="hljs-class"><span class="hljs-title">virtual</span> <span class="hljs-title">bool</span> <span class="hljs-title">hit</span>(<span class="hljs-title">ray</span> <span class="hljs-title">e</span>+<span class="hljs-title">td</span>, <span class="hljs-title">real</span> <span class="hljs-title">t_0</span>, <span class="hljs-title">real</span> <span class="hljs-title">t_1</span>, <span class="hljs-title">hit</span>-<span class="hljs-title">record</span> <span class="hljs-title">rec</span>)</span><br><span class="hljs-class"><span class="hljs-title">virtual</span> <span class="hljs-title">box</span> <span class="hljs-title">bounding</span>-<span class="hljs-title">box</span>()</span><br></code></pre></td></tr></table></figure><p>rec是一个用于返回的引用参数，返回如相交时的t值等。</p><h2 id="4-7-Shadows"><a href="#4-7-Shadows" class="headerlink" title="4.7 Shadows"></a>4.7 Shadows</h2><p>在如前所述的框架下，要考虑阴影是简单的。当检测到碰撞后，我们可以从返回的信息中得到光线向量$\pmb{l}$，此时的碰撞点亦已知，那么，只要我们从该碰撞点向光源方向“望去”，或者说发出一条射线并在遇到光源前检测到与其他物体的碰撞，说明此处为阴影，否则可以被照射。</p><p>不同于viewing ray，此处放出的射线，我们定义为shadow ray。如下图所示，还有一个要注意的问题是，我们的shadow ray可能因为数值计算的精度关系，检测到与p点所在的平面的相交情况！为了避免这种错误，我们常常设置一个极小值$\varepsilon$：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled9.png" alt="Untitled9.png"></p><p>于是，借助此前的hit函数，我们可以定义完整的返回pixel color的函数，详见p86：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">function <span class="hljs-title">raycolor</span><span class="hljs-params">(ray e+td, real t_0, real t_1)</span></span><br>hit-record rec, srec<br><span class="hljs-comment">//检测到与某物体表面相交</span><br><span class="hljs-keyword">if</span>(scene-&gt;<span class="hljs-built_in">hit</span>(ray, t_0, t_1, rec)) then<br><span class="hljs-comment">//计算相交位置</span><br>p = e + rec.t*d<br><span class="hljs-comment">//计算环境光分量</span><br>color c = rec.k_a*I_a<br><span class="hljs-comment">//检测碰撞</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> scene-&gt;<span class="hljs-built_in">hit</span>(p+sl, epsilon, infinite, srec)) then<br>calculate vector3 h = <span class="hljs-built_in">normalized</span>(l + (-d))<br>c = c + rec.k_d*I*<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, rec.n*l) + rec.k_s*I*<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, rec.n*h)^(rec.p)<br><span class="hljs-keyword">return</span> c<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> background-color<br></code></pre></td></tr></table></figure><h2 id="4-8-Ideal-Specular-Reflection"><a href="#4-8-Ideal-Specular-Reflection" class="headerlink" title="4.8 Ideal Specular Reflection"></a>4.8 Ideal Specular Reflection</h2><p>为了更为真实的镜面反射效果，我们可以模拟一面镜子的效果，这需要我们在与镜子的交点处再发出一条对称的视线，如下图所示：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter4%20Ray%20Tracing/Untitled10.png" alt="Untitled10.png"></p><p>向量r可由下式得到：</p><p>$$\pmb{r} = \pmb{d} - 2(\pmb{d\cdot n})\pmb{n}$$</p><p>借助于此前所函数raycolor，我们需要清楚这一函数完成了什么工作：在指定的相机参考系中，放出一条光线，并返回应该得到的着色值，我们只需要将这条放出的光线替换为r即可，最终的着色值为<code>color c = c + k_m*raycolor(p+sr, epsilon, infinite)</code> ，其中的k_m代表着反射镜面的系数，p为镜面上的相交点，取区间为$[\varepsilon, \infty)$的意义与shadow ray一致：防止检测到与镜面本身的碰撞。</p><p>当然，为了防止这一递归式无尽地计算(这一情况还是比较常见的，就比如把两块镜子摆在一起)。通常的解决方案是设定一个最大的递归深度(但是到递归深度以后的默认值该如何选取？不懂)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fundamental of CG研习：Chapter3 Raster Images</title>
    <link href="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter3%20Raster%20Images/"/>
    <url>/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter3%20Raster%20Images/</url>
    
    <content type="html"><![CDATA[<h1 id="3-Raster-Images"><a href="#3-Raster-Images" class="headerlink" title="3 Raster Images"></a>3 Raster Images</h1><p>章名为光栅图像。</p><p>为了在显示屏上显示图像，计算机需要将图像处理为以像素点表示的数据，即光栅化。每个像素可以发出红绿蓝光以合成为任意颜色。</p><p>而电脑处理的图像通常分为两类，raster image与vector image。在理想的情况下，raster image中的每一个像素点可以对应显示屏上的每一个像素点，但在大多数情况下，无法做到这种一一对应的关系。vector image的好处则在于支持任意尺度的缩放而不受到影响，这种图像以线段，曲线，形状进行描述，存在的问题是，要将这种较为抽象的图像显示出来，需要先经过光栅化的过程，这也是本章的主要论题。</p><h2 id="3-1-Raster-Device"><a href="#3-1-Raster-Device" class="headerlink" title="3.1 Raster Device"></a>3.1 Raster Device</h2><p>在讨论光栅化图像之前，先来看看如何显示图像的设备。通常的显示设备可以分为LCD(liquid crystal display，液晶显示)与LED(light-emitting diode，发光二极管)，二者的详细区别在下节叙述：</p><h3 id="3-1-1"><a href="#3-1-1" class="headerlink" title="3.1.1"></a>3.1.1</h3><p>当今的显示器大多基于固定尺寸的像素阵列，如电视与数码放映机。而这些显示器又大多分为两类：</p><ul><li><p>emissive displays</p><p>  使用像素本身发射光线(LED)。</p></li><li><p>transmissive displays</p><p>  像素本身并不发光，而是控制通过其的光线能量(LCD)。</p></li></ul><p>LCD的原理比较有意思，而LED的原理较为容易理解。对LED来说，一个像素的光线由三个子像素发射，而三个子像素的尺寸很小，肉眼不可见，通过通过二极管的电流大小，可以控制每种颜色光的强度，经过混合就得到了多种颜色。而LCD的是通过液晶的特性，通过电压改变液晶朝向，再改变通过光的偏振方向，从而改变通过光的强度，做到对每种原色光的强度控制：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter3%20Raster%20Images/Untitled.png" alt="Untitled.png"></p><h3 id="3-1-2-Hardcopy-Devices"><a href="#3-1-2-Hardcopy-Devices" class="headerlink" title="3.1.2 Hardcopy Devices"></a>3.1.2 Hardcopy Devices</h3><p>这章并没有仔细看，随便讲讲，没什么意思。讲的是印刷设备的原理。对印刷设备而言，ppi可以表示像素的密度，而dpi(dots per inch)则表示一个黑白打印机，即像素点非黑即白的点密度。</p><h3 id="3-1-3-Input-Devices"><a href="#3-1-3-Input-Devices" class="headerlink" title="3.1.3 Input Devices"></a>3.1.3 Input Devices</h3><p>图像的输入设备当属相机。</p><h2 id="3-2-Images-Pixels-and-Geometry"><a href="#3-2-Images-Pixels-and-Geometry" class="headerlink" title="3.2 Images, Pixels, and Geometry"></a>3.2 Images, Pixels, and Geometry</h2><p>我们可以将一个待显示的图像抽象为函数：</p><p>$$I(x,y): R \rightarrow V$$</p><p>V表示像素的可能值集合，而R是图像的显示范围。对于彩色图像而言，V是一个三维向量，分别代表红，绿，蓝强度。</p><p>像素的坐标与屏幕的对应关系通常由下图表示：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter3%20Raster%20Images/Untitled1.png" alt="Untitled1.png"></p><p>若一幅图像的尺寸为$(n_x, n_y)$，这里的尺寸意义为像素点个数，那么该图像的显示范围可以表示为下式：</p><p>$$R = [-0.5, n_x-0.5]\times[-0.5, n_y-0.5]$$</p><h3 id="3-2-1-Pixel-Values"><a href="#3-2-1-Pixel-Values" class="headerlink" title="3.2.1 Pixel Values"></a>3.2.1 Pixel Values</h3><p>本章讨论像素值的储存方式。假设每个像素的值都由三个32位浮点数表示，那么图像的尺寸将非常巨大，我们需要减少这一数值。首先，由于设备的限制，我们当然不可能将像素的光强设为无限大，通常，我们取其值域为[0,1]。对于一个8bit图像，通常的做法是储存为0, 1/255…, 254/255, 1。</p><p>以浮点数的方式储存的图像通常称为high dynamic range images(HDR)，这种图像的值域较宽，与之相对的是以整数形式存储的图像，称为LDR images。无论何种图像，都希望可以做到减少存储所需要的内存空间。</p><p>以有限值域的方式存储图像所导致的第一个问题是clipping，即剪切。当需要的光强太高，例如拍摄太阳时，所有亮度大于我们所设定的最大像素亮度值的输入值都会被设为最大值，这造成了细节上的损失。同时，以有限精度编码图像会导致quantization artifacts，即图像中出现明显的分层现象，这是因为图像的编码方式或许精度过低，无法反映亮度的细微渐变变化。</p><h3 id="3-2-2-Monitor-Intensities-and-Gamma"><a href="#3-2-2-Monitor-Intensities-and-Gamma" class="headerlink" title="3.2.2 Monitor Intensities and Gamma"></a>3.2.2 Monitor Intensities and Gamma</h3><p>本章主要讨论图像的输入值如何经过处理后被显示在具体设备上的过程。</p><p>首先明确一点，我们需要达到的目的是什么？假设图像的输入范围为0到1，输入为0时，我们希望设备完全不发光，而输入为1时，我们希望设备的三个通道均以最大亮度显示，以显示最亮的白色，更远一些，当输入值为0.5时呢？理所当然地，我们希望此时设备所发射的光线能量为值为1时的恰好一半。</p><p>当然，此处我们暂且不论人眼对光的感知能力与光的能量并不成线性关系，因为这会使我们的讨论变得复杂而没有暂时必要。</p><p>问题在于，我们的设备输出能量与其接受的输入值对应关系时非线性的！以0.5输入为例，我们的输出能量可能仅有0.25，输入值与输出能量之间的关系可以用下式模拟：</p><p>$$displayed\ intensity = (maximum\ intensity)a^\gamma$$</p><p>a即输入值，当a为0/1时，显示能量依然是与输入值对应的，对其他输入值则并非如此。为了了解输入与输出能量的关系，我们需要求出公式中的$\gamma$，在这里，有一种巧妙的方式解决这一问题：</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter3%20Raster%20Images/Untitled2.png" alt="Untitled2.png"></p><p>公式中$\gamma$的求解需要其余三个量已知！我们需要找到当设备的输出能量恰好等于最大能量的一半时，输入值a到底是多少。如果能够得知此时的a值，那么可以解得：</p><p>$$\gamma = \frac{ln 0.5}{ln a}$$</p><p>可是如何调节设备使其输出的能量恰好为最大能量的一半呢？看到上图应该就会有答案。在左边，我们以棋盘的方式放置黑白像素，以使其比例为1：1，当像素点够密时，其呈现的外观与一副均匀的灰色图像无异，此时，我们需要用户手动调节右边图像的输入值，以使两边图像的亮度一致，此时，我们可以认为右边图像的输入值恰好使设备的输出为最大能量的一半！</p><p>这就是游戏中常常遇到的gamma亮度调节，这一方法用于求出设备的这一属性，被运用得相当广泛。通过求得$\gamma$值，我们对于这台设备的输入输出特性已然掌握，通过调节输入值，我们就可以使输出的能量与我们想要的效果达到一致！而非产生公式所描述的偏差：</p><p>$$a’ = a^{\frac{1}{\gamma}}$$</p><p>每当我们要输入a值给设备时，我们将其替换为a’，通过这种方式，得到设备的输出能量：</p><p>$$displayed\ intensity = (maximum\ intensity)(a^{\frac{1}{\gamma}})^\gamma = a(maximum\ intensity)$$</p><p>这就是我们想要的效果！</p><h2 id="3-3-RGB-Color"><a href="#3-3-RGB-Color" class="headerlink" title="3.3 RGB Color"></a>3.3 RGB Color</h2><p>以RGB表示的光混合方法是一种additive manner，这种混合方法是建立在我们的显示设备是依靠自发光而非反射光来进行显示的基础之上的。与之相对的混合方法为subtractive manner，其三原色为红黄蓝，印刷制品本身并不发光，故其为减法。</p><p>在以RGB方式表示色彩时，通常采用的方法是使用一个字节即0-255表示一个分量值，同样地，每个分量都会遇到伽马校正，即上界所介绍的问题，而每个分量都可以以相同的方法进行校正。</p><h2 id="3-4-Alpha-Compositing"><a href="#3-4-Alpha-Compositing" class="headerlink" title="3.4 Alpha Compositing"></a>3.4 Alpha Compositing</h2><p>本节考虑如何处理半透明物体如玻璃等,同样地, 当前景与后景分别占到一个像素的一部分时, 也需要考虑两部分混合的问题.</p><p>自然地, 我们考虑颜色为$c_f$的前景物体所占单个像素比例为$\alpha$时, 有该像素颜色为:</p><p>$$c = \alpha c_f + (1-\alpha)c_b$$</p><p>而对于一些半透明的图像, 我们需要利用alpha通道去存储这一像素的透明度, alpha通道和RGB三通道共同描述了一个RGBA图像:</p><p><img src="/myBlog.github.io/2021/07/20/Fundamental%20of%20CG%E7%A0%94%E4%B9%A0%EF%BC%9AChapter3%20Raster%20Images/Untitled3.png" alt="Untitled3.png"></p><h3 id="3-4-1-Image-Storage"><a href="#3-4-1-Image-Storage" class="headerlink" title="3.4.1 Image Storage"></a>3.4.1 Image Storage</h3><p>要完全地存储某一图像的全部信息, 例如说, RGB图像的每个通道都使用8bit去描述, 根据图像的像素数量我们当然可以轻松计算这一图像的大小, 往往比较大, 这就需要进行压缩, 分lossless即无损与lossy有损两种方式. 常见的jpeg格式为有损的, 而tiff, ppm, png则是无损的格式.</p><h2 id="一个有趣的问题"><a href="#一个有趣的问题" class="headerlink" title="一个有趣的问题"></a>一个有趣的问题</h2><p>为什么我们不在制造显示器时即调试好设备, 使其在接收到输入时线性地输出能量, 而是需要用户进行手动调节?</p><p>看不懂书上的解释, mark先啦.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
